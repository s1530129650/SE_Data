"protected final void bindIndexed(ConfigurationPropertyName name, Bindable<?> target,\n\t\t\tAggregateElementBinder elementBinder, ResolvableType aggregateType,\n\t\t\tResolvableType elementType, IndexedCollectionSupplier result) {\n\t\tfor (ConfigurationPropertySource source : getContext().getSources()) {\n\t\t\tbindIndexed(source, name, target, elementBinder, result, aggregateType,\n\t\t\t\t\telementType);\n\t\t\tif (result.wasSupplied() && result.get() != null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}"
"public void setServletRegistrationBeans(\n\t\t\tCollection<? extends ServletRegistrationBean<?>> servletRegistrationBeans) {\n\t\tAssert.notNull(servletRegistrationBeans,\n\t\t\t\t\"ServletRegistrationBeans must not be null\");\n\t\tthis.servletRegistrationBeans = new LinkedHashSet<>(servletRegistrationBeans);\n\t}"
"public void addServletRegistrationBeans(\n\t\t\tServletRegistrationBean<?>... servletRegistrationBeans) {\n\t\tAssert.notNull(servletRegistrationBeans,\n\t\t\t\t\"ServletRegistrationBeans must not be null\");\n\t\tCollections.addAll(this.servletRegistrationBeans, servletRegistrationBeans);\n\t}"
"public void setServletNames(Collection<String> servletNames) {\n\t\tAssert.notNull(servletNames, \"ServletNames must not be null\");\n\t\tthis.servletNames = new LinkedHashSet<>(servletNames);\n\t}"
"public void addServletNames(String... servletNames) {\n\t\tAssert.notNull(servletNames, \"ServletNames must not be null\");\n\t\tthis.servletNames.addAll(Arrays.asList(servletNames));\n\t}"
"public void setUrlPatterns(Collection<String> urlPatterns) {\n\t\tAssert.notNull(urlPatterns, \"UrlPatterns must not be null\");\n\t\tthis.urlPatterns = new LinkedHashSet<>(urlPatterns);\n\t}"
"public void addUrlPatterns(String... urlPatterns) {\n\t\tAssert.notNull(urlPatterns, \"UrlPatterns must not be null\");\n\t\tCollections.addAll(this.urlPatterns, urlPatterns);\n\t}"
"public void setDispatcherTypes(DispatcherType first, DispatcherType... rest) {\n\t\tthis.dispatcherTypes = EnumSet.of(first, rest);\n\t}"
"@Override\n\tprotected void configure(FilterRegistration.Dynamic registration) {\n\t\tsuper.configure(registration);\n\t\tEnumSet<DispatcherType> dispatcherTypes = this.dispatcherTypes;\n\t\tif (dispatcherTypes == null) {\n\t\t\tdispatcherTypes = EnumSet.of(DispatcherType.REQUEST);\n\t\t}\n\t\tSet<String> servletNames = new LinkedHashSet<>();\n\t\tfor (ServletRegistrationBean<?> servletRegistrationBean : this.servletRegistrationBeans) {\n\t\t\tservletNames.add(servletRegistrationBean.getServletName());\n\t\t}\n\t\tservletNames.addAll(this.servletNames);\n\t\tif (servletNames.isEmpty() && this.urlPatterns.isEmpty()) {\n\t\t\tregistration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter,\n\t\t\t\t\tDEFAULT_URL_MAPPINGS);\n\t\t}\n\t\telse {\n\t\t\tif (!servletNames.isEmpty()) {\n\t\t\t\tregistration.addMappingForServletNames(dispatcherTypes, this.matchAfter,\n\t\t\t\t\t\tStringUtils.toStringArray(servletNames));\n\t\t\t}\n\t\t\tif (!this.urlPatterns.isEmpty()) {\n\t\t\t\tregistration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter,\n\t\t\t\t\t\tStringUtils.toStringArray(this.urlPatterns));\n\t\t\t}\n\t\t}\n\t}"
"public DependencyCustomizer ifAnyMissingClasses(String... classNames) {\n\t\treturn new DependencyCustomizer(this) {\n\t\t\t@Override\n\t\t\tprotected boolean canAdd() {\n\t\t\t\tfor (String className : classNames) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDependencyCustomizer.this.loader.loadClass(className);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t}"
"public DependencyCustomizer ifAllMissingClasses(String... classNames) {\n\t\treturn new DependencyCustomizer(this) {\n\t\t\t@Override\n\t\t\tprotected boolean canAdd() {\n\t\t\t\tfor (String className : classNames) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDependencyCustomizer.this.loader.loadClass(className);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t// swallow exception and continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn DependencyCustomizer.this.canAdd();\n\t\t\t}\n\t\t};\n\t}"
"public DependencyCustomizer ifAllResourcesPresent(String... paths) {\n\t\treturn new DependencyCustomizer(this) {\n\t\t\t@Override\n\t\t\tprotected boolean canAdd() {\n\t\t\t\tfor (String path : paths) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (DependencyCustomizer.this.loader.getResource(path) == null) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t// swallow exception and continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn DependencyCustomizer.this.canAdd();\n\t\t\t}\n\t\t};\n\t}"
"public DependencyCustomizer add(String... modules) {\n\t\tfor (String module : modules) {\n\t\t\tadd(module, null, null, true);\n\t\t}\n\t\treturn this;\n\t}"
"public DependencyCustomizer add(String module, boolean transitive) {\n\t\treturn add(module, null, null, transitive);\n\t}"
"public DependencyCustomizer add(String module, String classifier, String type,\n\t\t\tboolean transitive) {\n\t\tif (canAdd()) {\n\t\t\tArtifactCoordinatesResolver artifactCoordinatesResolver = this.dependencyResolutionContext\n\t\t\t\t\t.getArtifactCoordinatesResolver();\n\t\t\tthis.classNode.addAnnotation(\n\t\t\t\t\tcreateGrabAnnotation(artifactCoordinatesResolver.getGroupId(module),\n\t\t\t\t\t\t\tartifactCoordinatesResolver.getArtifactId(module),\n\t\t\t\t\t\t\tartifactCoordinatesResolver.getVersion(module), classifier,\n\t\t\t\t\t\t\ttype, transitive));\n\t\t}\n\t\treturn this;\n\t}"
"public ReactiveHealthIndicatorRegistry createReactiveHealthIndicatorRegistry(\n\t\t\tMap<String, ReactiveHealthIndicator> reactiveHealthIndicators,\n\t\t\tMap<String, HealthIndicator> healthIndicators) {\n\t\tAssert.notNull(reactiveHealthIndicators,\n\t\t\t\t\"ReactiveHealthIndicators must not be null\");\n\t\treturn initialize(new DefaultReactiveHealthIndicatorRegistry(),\n\t\t\t\treactiveHealthIndicators, healthIndicators);\n\t}"
"public RandomAccessData parse(RandomAccessData data, boolean skipPrefixBytes)\n\t\t\tthrows IOException {\n\t\tCentralDirectoryEndRecord endRecord = new CentralDirectoryEndRecord(data);\n\t\tif (skipPrefixBytes) {\n\t\t\tdata = getArchiveData(endRecord, data);\n\t\t}\n\t\tRandomAccessData centralDirectoryData = endRecord.getCentralDirectory(data);\n\t\tvisitStart(endRecord, centralDirectoryData);\n\t\tparseEntries(endRecord, centralDirectoryData);\n\t\tvisitEnd();\n\t\treturn data;\n\t}"
"protected final <V> V get(Function<T, V> getter, Supplier<V> fallback) {\n\t\tV value = getter.apply(this.properties);\n\t\treturn (value != null) ? value : fallback.get();\n\t}"
"public File getDir(String subDir) {\n\t\tFile dir = new File(getDir(), subDir);\n\t\tdir.mkdirs();\n\t\treturn dir;\n\t}"
"public File getDir() {\n\t\tif (this.dir == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\tbyte[] hash = generateHash(this.sourceClass);\n\t\t\t\tthis.dir = new File(getTempDirectory(), toHexString(hash));\n\t\t\t\tthis.dir.mkdirs();\n\t\t\t\tAssert.state(this.dir.exists(),\n\t\t\t\t\t\t() -> \"Unable to create temp directory \" + this.dir);\n\t\t\t}\n\t\t}\n\t\treturn this.dir;\n\t}"
"protected Map<String, Object> generateContent() {\n\t\tMap<String, Object> content = extractContent(toPropertySource());\n\t\tpostProcessContent(content);\n\t\treturn content;\n\t}"
"protected Map<String, Object> extractContent(PropertySource<?> propertySource) {\n\t\treturn new Binder(ConfigurationPropertySources.from(propertySource))\n\t\t\t\t.bind(\"\", STRING_OBJECT_MAP).orElseGet(LinkedHashMap::new);\n\t}"
"protected void copyIfSet(Properties target, String key) {\n\t\tString value = this.properties.get(key);\n\t\tif (StringUtils.hasText(value)) {\n\t\t\ttarget.put(key, value);\n\t\t}\n\t}"
"protected void replaceValue(Map<String, Object> content, String key, Object value) {\n\t\tif (content.containsKey(key) && value != null) {\n\t\t\tcontent.put(key, value);\n\t\t}\n\t}"
"@SuppressWarnings(\"unchecked\")\n\tprotected Map<String, Object> getNestedMap(Map<String, Object> map, String key) {\n\t\tObject value = map.get(key);\n\t\tif (value == null) {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\t\treturn (Map<String, Object>) value;\n\t}"
"@ReadOperation\n\tpublic Health healthForComponent(@Selector String component) {\n\t\tHealthIndicator indicator = getNestedHealthIndicator(this.healthIndicator,\n\t\t\t\tcomponent);\n\t\treturn (indicator != null) ? indicator.health() : null;\n\t}"
"@ReadOperation\n\tpublic Health healthForComponentInstance(@Selector String component,\n\t\t\t@Selector String instance) {\n\t\tHealthIndicator indicator = getNestedHealthIndicator(this.healthIndicator,\n\t\t\t\tcomponent);\n\t\tHealthIndicator nestedIndicator = getNestedHealthIndicator(indicator, instance);\n\t\treturn (nestedIndicator != null) ? nestedIndicator.health() : null;\n\t}"
"public static MeterValue valueOf(String value) {\n\t\tif (isNumber(value)) {\n\t\t\treturn new MeterValue(Long.parseLong(value));\n\t\t}\n\t\treturn new MeterValue(DurationStyle.detectAndParse(value));\n\t}"
"public static <C, A> Callback<C, A> callback(Class<C> callbackType,\n\t\t\tC callbackInstance, A argument, Object... additionalArguments) {\n\t\tAssert.notNull(callbackType, \"CallbackType must not be null\");\n\t\tAssert.notNull(callbackInstance, \"CallbackInstance must not be null\");\n\t\treturn new Callback<>(callbackType, callbackInstance, argument,\n\t\t\t\tadditionalArguments);\n\t}"
"public static <C, A> Callbacks<C, A> callbacks(Class<C> callbackType,\n\t\t\tCollection<? extends C> callbackInstances, A argument,\n\t\t\tObject... additionalArguments) {\n\t\tAssert.notNull(callbackType, \"CallbackType must not be null\");\n\t\tAssert.notNull(callbackInstances, \"CallbackInstances must not be null\");\n\t\treturn new Callbacks<>(callbackType, callbackInstances, argument,\n\t\t\t\tadditionalArguments);\n\t}"
"public <R> Stream<R> invokeAnd(Function<C, R> invoker) {\n\t\t\tFunction<C, InvocationResult<R>> mapper = (callbackInstance) -> invoke(\n\t\t\t\t\tcallbackInstance, () -> invoker.apply(callbackInstance));\n\t\t\treturn this.callbackInstances.stream().map(mapper)\n\t\t\t\t\t.filter(InvocationResult::hasResult).map(InvocationResult::get);\n\t\t}"
"public int start() throws IOException {\n\t\tsynchronized (this.monitor) {\n\t\t\tAssert.state(!isStarted(), \"Server already started\");\n\t\t\tlogger.debug(\"Starting live reload server on port \" + this.port);\n\t\t\tthis.serverSocket = new ServerSocket(this.port);\n\t\t\tint localPort = this.serverSocket.getLocalPort();\n\t\t\tthis.listenThread = this.threadFactory.newThread(this::acceptConnections);\n\t\t\tthis.listenThread.setDaemon(true);\n\t\t\tthis.listenThread.setName(\"Live Reload Server\");\n\t\t\tthis.listenThread.start();\n\t\t\treturn localPort;\n\t\t}\n\t}"
"public void stop() throws IOException {\n\t\tsynchronized (this.monitor) {\n\t\t\tif (this.listenThread != null) {\n\t\t\t\tcloseAllConnections();\n\t\t\t\ttry {\n\t\t\t\t\tthis.executor.shutdown();\n\t\t\t\t\tthis.executor.awaitTermination(1, TimeUnit.MINUTES);\n\t\t\t\t}\n\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t}\n\t\t\t\tthis.serverSocket.close();\n\t\t\t\ttry {\n\t\t\t\t\tthis.listenThread.join();\n\t\t\t\t}\n\t\t\t\tcatch (InterruptedException ex) {\n\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t}\n\t\t\t\tthis.listenThread = null;\n\t\t\t\tthis.serverSocket = null;\n\t\t\t}\n\t\t}\n\t}"
"public void triggerReload() {\n\t\tsynchronized (this.monitor) {\n\t\t\tsynchronized (this.connections) {\n\t\t\t\tfor (Connection connection : this.connections) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconnection.triggerReload();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tlogger.debug(\"Unable to send reload message\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
"protected Connection createConnection(Socket socket, InputStream inputStream,\n\t\t\tOutputStream outputStream) throws IOException {\n\t\treturn new Connection(socket, inputStream, outputStream);\n\t}"
"public ConfigurableApplicationContext run(String... args) {\n\t\tif (this.running.get()) {\n\t\t\t// If already created we just return the existing context\n\t\t\treturn this.context;\n\t\t}\n\t\tconfigureAsChildIfNecessary(args);\n\t\tif (this.running.compareAndSet(false, true)) {\n\t\t\tsynchronized (this.running) {\n\t\t\t\t// If not already running copy the sources over and then run.\n\t\t\t\tthis.context = build().run(args);\n\t\t\t}\n\t\t}\n\t\treturn this.context;\n\t}"
"public SpringApplication build(String... args) {\n\t\tconfigureAsChildIfNecessary(args);\n\t\tthis.application.addPrimarySources(this.sources);\n\t\treturn this.application;\n\t}"
"public SpringApplicationBuilder child(Class<?>... sources) {\n\t\tSpringApplicationBuilder child = new SpringApplicationBuilder();\n\t\tchild.sources(sources);\n\n\t\t// Copy environment stuff from parent to child\n\t\tchild.properties(this.defaultProperties).environment(this.environment)\n\t\t\t\t.additionalProfiles(this.additionalProfiles);\n\t\tchild.parent = this;\n\n\t\t// It's not possible if embedded web server are enabled to support web contexts as\n\t\t// parents because the servlets cannot be initialized at the right point in\n\t\t// lifecycle.\n\t\tweb(WebApplicationType.NONE);\n\n\t\t// Probably not interested in multiple banners\n\t\tbannerMode(Banner.Mode.OFF);\n\n\t\t// Make sure sources get copied over\n\t\tthis.application.addPrimarySources(this.sources);\n\n\t\treturn child;\n\t}"
"public SpringApplicationBuilder parent(Class<?>... sources) {\n\t\tif (this.parent == null) {\n\t\t\tthis.parent = new SpringApplicationBuilder(sources)\n\t\t\t\t\t.web(WebApplicationType.NONE).properties(this.defaultProperties)\n\t\t\t\t\t.environment(this.environment);\n\t\t}\n\t\telse {\n\t\t\tthis.parent.sources(sources);\n\t\t}\n\t\treturn this.parent;\n\t}"
"public SpringApplicationBuilder parent(ConfigurableApplicationContext parent) {\n\t\tthis.parent = new SpringApplicationBuilder();\n\t\tthis.parent.context = parent;\n\t\tthis.parent.running.set(true);\n\t\treturn this;\n\t}"
"public SpringApplicationBuilder sibling(Class<?>[] sources, String... args) {\n\t\treturn runAndExtractParent(args).child(sources);\n\t}"
"public SpringApplicationBuilder sources(Class<?>... sources) {\n\t\tthis.sources.addAll(new LinkedHashSet<>(Arrays.asList(sources)));\n\t\treturn this;\n\t}"
"public SpringApplicationBuilder properties(Map<String, Object> defaults) {\n\t\tthis.defaultProperties.putAll(defaults);\n\t\tthis.application.setDefaultProperties(this.defaultProperties);\n\t\tif (this.parent != null) {\n\t\t\tthis.parent.properties(this.defaultProperties);\n\t\t\tthis.parent.environment(this.environment);\n\t\t}\n\t\treturn this;\n\t}"
"public SpringApplicationBuilder profiles(String... profiles) {\n\t\tthis.additionalProfiles.addAll(Arrays.asList(profiles));\n\t\tthis.application.setAdditionalProfiles(\n\t\t\t\tStringUtils.toStringArray(this.additionalProfiles));\n\t\treturn this;\n\t}"
"public static ConversionService getSharedInstance() {\n\t\tApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance;\n\t\tif (sharedInstance == null) {\n\t\t\tsynchronized (ApplicationConversionService.class) {\n\t\t\t\tsharedInstance = ApplicationConversionService.sharedInstance;\n\t\t\t\tif (sharedInstance == null) {\n\t\t\t\t\tsharedInstance = new ApplicationConversionService();\n\t\t\t\t\tApplicationConversionService.sharedInstance = sharedInstance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sharedInstance;\n\t}"
"public static void configure(FormatterRegistry registry) {\n\t\tDefaultConversionService.addDefaultConverters(registry);\n\t\tDefaultFormattingConversionService.addDefaultFormatters(registry);\n\t\taddApplicationFormatters(registry);\n\t\taddApplicationConverters(registry);\n\t}"
"public static void addApplicationConverters(ConverterRegistry registry) {\n\t\taddDelimitedStringConverters(registry);\n\t\tregistry.addConverter(new StringToDurationConverter());\n\t\tregistry.addConverter(new DurationToStringConverter());\n\t\tregistry.addConverter(new NumberToDurationConverter());\n\t\tregistry.addConverter(new DurationToNumberConverter());\n\t\tregistry.addConverter(new StringToDataSizeConverter());\n\t\tregistry.addConverter(new NumberToDataSizeConverter());\n\t\tregistry.addConverterFactory(new StringToEnumIgnoringCaseConverterFactory());\n\t}"
"public static void addDelimitedStringConverters(ConverterRegistry registry) {\n\t\tConversionService service = (ConversionService) registry;\n\t\tregistry.addConverter(new ArrayToDelimitedStringConverter(service));\n\t\tregistry.addConverter(new CollectionToDelimitedStringConverter(service));\n\t\tregistry.addConverter(new DelimitedStringToArrayConverter(service));\n\t\tregistry.addConverter(new DelimitedStringToCollectionConverter(service));\n\t}"
"public static void addApplicationFormatters(FormatterRegistry registry) {\n\t\tregistry.addFormatter(new CharArrayFormatter());\n\t\tregistry.addFormatter(new InetAddressFormatter());\n\t\tregistry.addFormatter(new IsoOffsetFormatter());\n\t}"
"public void setServerCustomizers(\n\t\t\tCollection<? extends ServerRSocketFactoryCustomizer> serverCustomizers) {\n\t\tAssert.notNull(serverCustomizers, \"ServerCustomizers must not be null\");\n\t\tthis.serverCustomizers = new ArrayList<>(serverCustomizers);\n\t}"
"public void addServerCustomizers(\n\t\t\tServerRSocketFactoryCustomizer... serverCustomizers) {\n\t\tAssert.notNull(serverCustomizers, \"ServerCustomizer must not be null\");\n\t\tthis.serverCustomizers.addAll(Arrays.asList(serverCustomizers));\n\t}"
"public MultipartConfigElement createMultipartConfig() {\n\t\tlong maxFileSizeBytes = convertToBytes(this.maxFileSize, -1);\n\t\tlong maxRequestSizeBytes = convertToBytes(this.maxRequestSize, -1);\n\t\tlong fileSizeThresholdBytes = convertToBytes(this.fileSizeThreshold, 0);\n\t\treturn new MultipartConfigElement(this.location, maxFileSizeBytes,\n\t\t\t\tmaxRequestSizeBytes, (int) fileSizeThresholdBytes);\n\t}"
"private long convertToBytes(DataSize size, int defaultValue) {\n\t\tif (size != null && !size.isNegative()) {\n\t\t\treturn size.toBytes();\n\t\t}\n\t\treturn defaultValue;\n\t}"
"public DataSourceBuilder<?> initializeDataSourceBuilder() {\n\t\treturn DataSourceBuilder.create(getClassLoader()).type(getType())\n\t\t\t\t.driverClassName(determineDriverClassName()).url(determineUrl())\n\t\t\t\t.username(determineUsername()).password(determinePassword());\n\t}"
"public String determineDriverClassName() {\n\t\tif (StringUtils.hasText(this.driverClassName)) {\n\t\t\tAssert.state(driverClassIsLoadable(),\n\t\t\t\t\t() -> \"Cannot load driver class: \" + this.driverClassName);\n\t\t\treturn this.driverClassName;\n\t\t}\n\t\tString driverClassName = null;\n\t\tif (StringUtils.hasText(this.url)) {\n\t\t\tdriverClassName = DatabaseDriver.fromJdbcUrl(this.url).getDriverClassName();\n\t\t}\n\t\tif (!StringUtils.hasText(driverClassName)) {\n\t\t\tdriverClassName = this.embeddedDatabaseConnection.getDriverClassName();\n\t\t}\n\t\tif (!StringUtils.hasText(driverClassName)) {\n\t\t\tthrow new DataSourceBeanCreationException(\n\t\t\t\t\t\"Failed to determine a suitable driver class\", this,\n\t\t\t\t\tthis.embeddedDatabaseConnection);\n\t\t}\n\t\treturn driverClassName;\n\t}"
"public String determineUrl() {\n\t\tif (StringUtils.hasText(this.url)) {\n\t\t\treturn this.url;\n\t\t}\n\t\tString databaseName = determineDatabaseName();\n\t\tString url = (databaseName != null)\n\t\t\t\t? this.embeddedDatabaseConnection.getUrl(databaseName) : null;\n\t\tif (!StringUtils.hasText(url)) {\n\t\t\tthrow new DataSourceBeanCreationException(\n\t\t\t\t\t\"Failed to determine suitable jdbc url\", this,\n\t\t\t\t\tthis.embeddedDatabaseConnection);\n\t\t}\n\t\treturn url;\n\t}"
"public String determineDatabaseName() {\n\t\tif (this.generateUniqueName) {\n\t\t\tif (this.uniqueName == null) {\n\t\t\t\tthis.uniqueName = UUID.randomUUID().toString();\n\t\t\t}\n\t\t\treturn this.uniqueName;\n\t\t}\n\t\tif (StringUtils.hasLength(this.name)) {\n\t\t\treturn this.name;\n\t\t}\n\t\tif (this.embeddedDatabaseConnection != EmbeddedDatabaseConnection.NONE) {\n\t\t\treturn \"testdb\";\n\t\t}\n\t\treturn null;\n\t}"
"public String determineUsername() {\n\t\tif (StringUtils.hasText(this.username)) {\n\t\t\treturn this.username;\n\t\t}\n\t\tif (EmbeddedDatabaseConnection.isEmbedded(determineDriverClassName())) {\n\t\t\treturn \"sa\";\n\t\t}\n\t\treturn null;\n\t}"
"public String determinePassword() {\n\t\tif (StringUtils.hasText(this.password)) {\n\t\t\treturn this.password;\n\t\t}\n\t\tif (EmbeddedDatabaseConnection.isEmbedded(determineDriverClassName())) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn null;\n\t}"
"@SuppressWarnings({ \"unchecked\" })\n\tprotected final <D> D nullSafeValue(JsonNode jsonNode, Class<D> type) {\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\tif (jsonNode == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (type == String.class) {\n\t\t\treturn (D) jsonNode.textValue();\n\t\t}\n\t\tif (type == Boolean.class) {\n\t\t\treturn (D) Boolean.valueOf(jsonNode.booleanValue());\n\t\t}\n\t\tif (type == Long.class) {\n\t\t\treturn (D) Long.valueOf(jsonNode.longValue());\n\t\t}\n\t\tif (type == Integer.class) {\n\t\t\treturn (D) Integer.valueOf(jsonNode.intValue());\n\t\t}\n\t\tif (type == Short.class) {\n\t\t\treturn (D) Short.valueOf(jsonNode.shortValue());\n\t\t}\n\t\tif (type == Double.class) {\n\t\t\treturn (D) Double.valueOf(jsonNode.doubleValue());\n\t\t}\n\t\tif (type == Float.class) {\n\t\t\treturn (D) Float.valueOf(jsonNode.floatValue());\n\t\t}\n\t\tif (type == BigDecimal.class) {\n\t\t\treturn (D) jsonNode.decimalValue();\n\t\t}\n\t\tif (type == BigInteger.class) {\n\t\t\treturn (D) jsonNode.bigIntegerValue();\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Unsupported value type \" + type.getName());\n\t}"
"protected final JsonNode getRequiredNode(JsonNode tree, String fieldName) {\n\t\tAssert.notNull(tree, \"Tree must not be null\");\n\t\tJsonNode node = tree.get(fieldName);\n\t\tAssert.state(node != null && !(node instanceof NullNode),\n\t\t\t\t() -> \"Missing JSON field '\" + fieldName + \"'\");\n\t\treturn node;\n\t}"
"public JmsPoolConnectionFactory createPooledConnectionFactory(\n\t\t\tConnectionFactory connectionFactory) {\n\t\tJmsPoolConnectionFactory pooledConnectionFactory = new JmsPoolConnectionFactory();\n\t\tpooledConnectionFactory.setConnectionFactory(connectionFactory);\n\n\t\tpooledConnectionFactory\n\t\t\t\t.setBlockIfSessionPoolIsFull(this.properties.isBlockIfFull());\n\t\tif (this.properties.getBlockIfFullTimeout() != null) {\n\t\t\tpooledConnectionFactory.setBlockIfSessionPoolIsFullTimeout(\n\t\t\t\t\tthis.properties.getBlockIfFullTimeout().toMillis());\n\t\t}\n\t\tif (this.properties.getIdleTimeout() != null) {\n\t\t\tpooledConnectionFactory.setConnectionIdleTimeout(\n\t\t\t\t\t(int) this.properties.getIdleTimeout().toMillis());\n\t\t}\n\t\tpooledConnectionFactory.setMaxConnections(this.properties.getMaxConnections());\n\t\tpooledConnectionFactory.setMaxSessionsPerConnection(\n\t\t\t\tthis.properties.getMaxSessionsPerConnection());\n\t\tif (this.properties.getTimeBetweenExpirationCheck() != null) {\n\t\t\tpooledConnectionFactory.setConnectionCheckInterval(\n\t\t\t\t\tthis.properties.getTimeBetweenExpirationCheck().toMillis());\n\t\t}\n\t\tpooledConnectionFactory\n\t\t\t\t.setUseAnonymousProducers(this.properties.isUseAnonymousProducers());\n\t\treturn pooledConnectionFactory;\n\t}"
"public ProjectGenerationResponse generate(ProjectGenerationRequest request)\n\t\t\tthrows IOException {\n\t\tLog.info(\"Using service at \" + request.getServiceUrl());\n\t\tInitializrServiceMetadata metadata = loadMetadata(request.getServiceUrl());\n\t\tURI url = request.generateUrl(metadata);\n\t\tCloseableHttpResponse httpResponse = executeProjectGenerationRequest(url);\n\t\tHttpEntity httpEntity = httpResponse.getEntity();\n\t\tvalidateResponse(httpResponse, request.getServiceUrl());\n\t\treturn createResponse(httpResponse, httpEntity);\n\t}"
"public InitializrServiceMetadata loadMetadata(String serviceUrl) throws IOException {\n\t\tCloseableHttpResponse httpResponse = executeInitializrMetadataRetrieval(\n\t\t\t\tserviceUrl);\n\t\tvalidateResponse(httpResponse, serviceUrl);\n\t\treturn parseJsonMetadata(httpResponse.getEntity());\n\t}"
"public Object loadServiceCapabilities(String serviceUrl) throws IOException {\n\t\tHttpGet request = new HttpGet(serviceUrl);\n\t\trequest.setHeader(\n\t\t\t\tnew BasicHeader(HttpHeaders.ACCEPT, ACCEPT_SERVICE_CAPABILITIES));\n\t\tCloseableHttpResponse httpResponse = execute(request, serviceUrl,\n\t\t\t\t\"retrieve help\");\n\t\tvalidateResponse(httpResponse, serviceUrl);\n\t\tHttpEntity httpEntity = httpResponse.getEntity();\n\t\tContentType contentType = ContentType.getOrDefault(httpEntity);\n\t\tif (contentType.getMimeType().equals(\"text/plain\")) {\n\t\t\treturn getContent(httpEntity);\n\t\t}\n\t\treturn parseJsonMetadata(httpEntity);\n\t}"
"private CloseableHttpResponse executeInitializrMetadataRetrieval(String url) {\n\t\tHttpGet request = new HttpGet(url);\n\t\trequest.setHeader(new BasicHeader(HttpHeaders.ACCEPT, ACCEPT_META_DATA));\n\t\treturn execute(request, url, \"retrieve metadata\");\n\t}"
"public PropertiesMigrationReport getReport() {\n\t\tPropertiesMigrationReport report = new PropertiesMigrationReport();\n\t\tMap<String, List<PropertyMigration>> properties = getMatchingProperties(\n\t\t\t\tdeprecatedFilter());\n\t\tif (properties.isEmpty()) {\n\t\t\treturn report;\n\t\t}\n\t\tproperties.forEach((name, candidates) -> {\n\t\t\tPropertySource<?> propertySource = mapPropertiesWithReplacement(report, name,\n\t\t\t\t\tcandidates);\n\t\t\tif (propertySource != null) {\n\t\t\t\tthis.environment.getPropertySources().addBefore(name, propertySource);\n\t\t\t}\n\t\t});\n\t\treturn report;\n\t}"
"public Collection<Resource> createEndpointResources(EndpointMapping endpointMapping,\n\t\t\tCollection<ExposableWebEndpoint> endpoints,\n\t\t\tEndpointMediaTypes endpointMediaTypes, EndpointLinksResolver linksResolver) {\n\t\tList<Resource> resources = new ArrayList<>();\n\t\tendpoints.stream().flatMap((endpoint) -> endpoint.getOperations().stream())\n\t\t\t\t.map((operation) -> createResource(endpointMapping, operation))\n\t\t\t\t.forEach(resources::add);\n\t\tif (StringUtils.hasText(endpointMapping.getPath())) {\n\t\t\tResource resource = createEndpointLinksResource(endpointMapping.getPath(),\n\t\t\t\t\tendpointMediaTypes, linksResolver);\n\t\t\tresources.add(resource);\n\t\t}\n\t\treturn resources;\n\t}"
"public StaticResourceServerWebExchange at(StaticResourceLocation first,\n\t\t\tStaticResourceLocation... rest) {\n\t\treturn at(EnumSet.of(first, rest));\n\t}"
"public StaticResourceServerWebExchange at(Set<StaticResourceLocation> locations) {\n\t\tAssert.notNull(locations, \"Locations must not be null\");\n\t\treturn new StaticResourceServerWebExchange(new LinkedHashSet<>(locations));\n\t}"
"StandardEnvironment convertEnvironmentIfNecessary(ConfigurableEnvironment environment,\n\t\t\tClass<? extends StandardEnvironment> type) {\n\t\tif (type.equals(environment.getClass())) {\n\t\t\treturn (StandardEnvironment) environment;\n\t\t}\n\t\treturn convertEnvironment(environment, type);\n\t}"
"public Set<String> getNamesForType(Class<?> type, TypeExtractor typeExtractor) {\n\t\tupdateTypesIfNecessary();\n\t\treturn this.beanTypes.entrySet().stream().filter((entry) -> {\n\t\t\tClass<?> beanType = extractType(entry.getValue(), typeExtractor);\n\t\t\treturn beanType != null && type.isAssignableFrom(beanType);\n\t\t}"
"@SuppressWarnings(\"unchecked\")\n\tpublic <T extends CacheManager> T customize(T cacheManager) {\n\t\tLambdaSafe.callbacks(CacheManagerCustomizer.class, this.customizers, cacheManager)\n\t\t\t\t.withLogger(CacheManagerCustomizers.class)\n\t\t\t\t.invoke((customizer) -> customizer.customize(cacheManager));\n\t\treturn cacheManager;\n\t}"
"public void compileAndRun() throws Exception {\n\t\tsynchronized (this.monitor) {\n\t\t\ttry {\n\t\t\t\tstop();\n\t\t\t\tClass<?>[] compiledSources = compile();\n\t\t\t\tmonitorForChanges();\n\t\t\t\t// Run in new thread to ensure that the context classloader is setup\n\t\t\t\tthis.runThread = new RunThread(compiledSources);\n\t\t\t\tthis.runThread.start();\n\t\t\t\tthis.runThread.join();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (this.fileWatchThread == null) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tex.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}"
"URI generateUrl(InitializrServiceMetadata metadata) {\n\t\ttry {\n\t\t\tURIBuilder builder = new URIBuilder(this.serviceUrl);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (builder.getPath() != null) {\n\t\t\t\tsb.append(builder.getPath());\n\t\t\t}\n\n\t\t\tProjectType projectType = determineProjectType(metadata);\n\t\t\tthis.type = projectType.getId();\n\t\t\tsb.append(projectType.getAction());\n\t\t\tbuilder.setPath(sb.toString());\n\n\t\t\tif (!this.dependencies.isEmpty()) {\n\t\t\t\tbuilder.setParameter(\"dependencies\",\n\t\t\t\t\t\tStringUtils.collectionToCommaDelimitedString(this.dependencies));\n\t\t\t}\n\n\t\t\tif (this.groupId != null) {\n\t\t\t\tbuilder.setParameter(\"groupId\", this.groupId);\n\t\t\t}\n\t\t\tString resolvedArtifactId = resolveArtifactId();\n\t\t\tif (resolvedArtifactId != null) {\n\t\t\t\tbuilder.setParameter(\"artifactId\", resolvedArtifactId);\n\t\t\t}\n\t\t\tif (this.version != null) {\n\t\t\t\tbuilder.setParameter(\"version\", this.version);\n\t\t\t}\n\t\t\tif (this.name != null) {\n\t\t\t\tbuilder.setParameter(\"name\", this.name);\n\t\t\t}\n\t\t\tif (this.description != null) {\n\t\t\t\tbuilder.setParameter(\"description\", this.description);\n\t\t\t}\n\t\t\tif (this.packageName != null) {\n\t\t\t\tbuilder.setParameter(\"packageName\", this.packageName);\n\t\t\t}\n\t\t\tif (this.type != null) {\n\t\t\t\tbuilder.setParameter(\"type\", projectType.getId());\n\t\t\t}\n\t\t\tif (this.packaging != null) {\n\t\t\t\tbuilder.setParameter(\"packaging\", this.packaging);\n\t\t\t}\n\t\t\tif (this.javaVersion != null) {\n\t\t\t\tbuilder.setParameter(\"javaVersion\", this.javaVersion);\n\t\t\t}\n\t\t\tif (this.language != null) {\n\t\t\t\tbuilder.setParameter(\"language\", this.language);\n\t\t\t}\n\t\t\tif (this.bootVersion != null) {\n\t\t\t\tbuilder.setParameter(\"bootVersion\", this.bootVersion);\n\t\t\t}\n\n\t\t\treturn builder.build();\n\t\t}\n\t\tcatch (URISyntaxException ex) {\n\t\t\tthrow new ReportableException(\n\t\t\t\t\t\"Invalid service URL (\" + ex.getMessage() + \")\");\n\t\t}\n\t}"
"protected String resolveArtifactId() {\n\t\tif (this.artifactId != null) {\n\t\t\treturn this.artifactId;\n\t\t}\n\t\tif (this.output != null) {\n\t\t\tint i = this.output.lastIndexOf('.');\n\t\t\treturn (i != -1) ? this.output.substring(0, i) : this.output;\n\t\t}\n\t\treturn null;\n\t}"
"protected final boolean anyMatches(ConditionContext context,\n\t\t\tAnnotatedTypeMetadata metadata, Condition... conditions) {\n\t\tfor (Condition condition : conditions) {\n\t\t\tif (matches(context, metadata, condition)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
"protected final boolean matches(ConditionContext context,\n\t\t\tAnnotatedTypeMetadata metadata, Condition condition) {\n\t\tif (condition instanceof SpringBootCondition) {\n\t\t\treturn ((SpringBootCondition) condition).getMatchOutcome(context, metadata)\n\t\t\t\t\t.isMatch();\n\t\t}\n\t\treturn condition.matches(context, metadata);\n\t}"
"private boolean isLogConfigurationMessage(Throwable ex) {\n\t\tif (ex instanceof InvocationTargetException) {\n\t\t\treturn isLogConfigurationMessage(ex.getCause());\n\t\t}\n\t\tString message = ex.getMessage();\n\t\tif (message != null) {\n\t\t\tfor (String candidate : LOG_CONFIGURATION_MESSAGES) {\n\t\t\t\tif (message.contains(candidate)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}"
"private void handle(ExecuteContext context, SQLExceptionTranslator translator,\n\t\t\tSQLException exception) {\n\t\tDataAccessException translated = translate(context, translator, exception);\n\t\tif (exception.getNextException() == null) {\n\t\t\tcontext.exception(translated);\n\t\t}\n\t\telse {\n\t\t\tlogger.error(\"Execution of SQL statement failed.\", translated);\n\t\t}\n\t}"
"public TaskSchedulerBuilder awaitTerminationPeriod(Duration awaitTerminationPeriod) {\n\t\treturn new TaskSchedulerBuilder(this.poolSize, this.awaitTermination,\n\t\t\t\tawaitTerminationPeriod, this.threadNamePrefix, this.customizers);\n\t}"
"public TaskSchedulerBuilder threadNamePrefix(String threadNamePrefix) {\n\t\treturn new TaskSchedulerBuilder(this.poolSize, this.awaitTermination,\n\t\t\t\tthis.awaitTerminationPeriod, threadNamePrefix, this.customizers);\n\t}"
"public TaskSchedulerBuilder customizers(TaskSchedulerCustomizer... customizers) {\n\t\tAssert.notNull(customizers, \"Customizers must not be null\");\n\t\treturn customizers(Arrays.asList(customizers));\n\t}"
"public TaskSchedulerBuilder customizers(\n\t\t\tIterable<TaskSchedulerCustomizer> customizers) {\n\t\tAssert.notNull(customizers, \"Customizers must not be null\");\n\t\treturn new TaskSchedulerBuilder(this.poolSize, this.awaitTermination,\n\t\t\t\tthis.awaitTerminationPeriod, this.threadNamePrefix,\n\t\t\t\tappend(null, customizers));\n\t}"
"public TaskSchedulerBuilder additionalCustomizers(\n\t\t\tTaskSchedulerCustomizer... customizers) {\n\t\tAssert.notNull(customizers, \"Customizers must not be null\");\n\t\treturn additionalCustomizers(Arrays.asList(customizers));\n\t}"
"public <T extends ThreadPoolTaskScheduler> T configure(T taskScheduler) {\n\t\tPropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();\n\t\tmap.from(this.poolSize).to(taskScheduler::setPoolSize);\n\t\tmap.from(this.awaitTermination)\n\t\t\t\t.to(taskScheduler::setWaitForTasksToCompleteOnShutdown);\n\t\tmap.from(this.awaitTerminationPeriod).asInt(Duration::getSeconds)\n\t\t\t\t.to(taskScheduler::setAwaitTerminationSeconds);\n\t\tmap.from(this.threadNamePrefix).to(taskScheduler::setThreadNamePrefix);\n\t\tif (!CollectionUtils.isEmpty(this.customizers)) {\n\t\t\tthis.customizers.forEach((customizer) -> customizer.customize(taskScheduler));\n\t\t}\n\t\treturn taskScheduler;\n\t}"
"public static LoggingSystem get(ClassLoader classLoader) {\n\t\tString loggingSystem = System.getProperty(SYSTEM_PROPERTY);\n\t\tif (StringUtils.hasLength(loggingSystem)) {\n\t\t\tif (NONE.equals(loggingSystem)) {\n\t\t\t\treturn new NoOpLoggingSystem();\n\t\t\t}\n\t\t\treturn get(classLoader, loggingSystem);\n\t\t}\n\t\treturn SYSTEMS.entrySet().stream()\n\t\t\t\t.filter((entry) -> ClassUtils.isPresent(entry.getKey(), classLoader))\n\t\t\t\t.map((entry) -> get(classLoader, entry.getValue())).findFirst()\n\t\t\t\t.orElseThrow(() -> new IllegalStateException(\n\t\t\t\t\t\t\"No suitable logging system located\"));\n\t}"
"public void addListener(FileChangeListener fileChangeListener) {\n\t\tAssert.notNull(fileChangeListener, \"FileChangeListener must not be null\");\n\t\tsynchronized (this.monitor) {\n\t\t\tcheckNotStarted();\n\t\t\tthis.listeners.add(fileChangeListener);\n\t\t}\n\t}"
"public void addSourceFolders(Iterable<File> folders) {\n\t\tAssert.notNull(folders, \"Folders must not be null\");\n\t\tsynchronized (this.monitor) {\n\t\t\tfor (File folder : folders) {\n\t\t\t\taddSourceFolder(folder);\n\t\t\t}\n\t\t}\n\t}"
"public void addSourceFolder(File folder) {\n\t\tAssert.notNull(folder, \"Folder must not be null\");\n\t\tAssert.isTrue(!folder.isFile(), \"Folder '\" + folder + \"' must not be a file\");\n\t\tsynchronized (this.monitor) {\n\t\t\tcheckNotStarted();\n\t\t\tthis.folders.put(folder, null);\n\t\t}\n\t}"
"public void start() {\n\t\tsynchronized (this.monitor) {\n\t\t\tsaveInitialSnapshots();\n\t\t\tif (this.watchThread == null) {\n\t\t\t\tMap<File, FolderSnapshot> localFolders = new HashMap<>();\n\t\t\t\tlocalFolders.putAll(this.folders);\n\t\t\t\tthis.watchThread = new Thread(new Watcher(this.remainingScans,\n\t\t\t\t\t\tnew ArrayList<>(this.listeners), this.triggerFilter,\n\t\t\t\t\t\tthis.pollInterval, this.quietPeriod, localFolders));\n\t\t\t\tthis.watchThread.setName(\"File Watcher\");\n\t\t\t\tthis.watchThread.setDaemon(this.daemon);\n\t\t\t\tthis.watchThread.start();\n\t\t\t}\n\t\t}\n\t}"
"void stopAfter(int remainingScans) {\n\t\tThread thread;\n\t\tsynchronized (this.monitor) {\n\t\t\tthread = this.watchThread;\n\t\t\tif (thread != null) {\n\t\t\t\tthis.remainingScans.set(remainingScans);\n\t\t\t\tif (remainingScans <= 0) {\n\t\t\t\t\tthread.interrupt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.watchThread = null;\n\t\t}\n\t\tif (thread != null && Thread.currentThread() != thread) {\n\t\t\ttry {\n\t\t\t\tthread.join();\n\t\t\t}\n\t\t\tcatch (InterruptedException ex) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\t\t}\n\t}"
"protected Map<String, Object> getErrorAttributes(ServerRequest request,\n\t\t\tboolean includeStackTrace) {\n\t\treturn this.errorAttributes.getErrorAttributes(request, includeStackTrace);\n\t}"
"protected boolean isTraceEnabled(ServerRequest request) {\n\t\tString parameter = request.queryParam(\"trace\").orElse(\"false\");\n\t\treturn !\"false\".equalsIgnoreCase(parameter);\n\t}"
"protected Mono<ServerResponse> renderErrorView(String viewName,\n\t\t\tServerResponse.BodyBuilder responseBody, Map<String, Object> error) {\n\t\tif (isTemplateAvailable(viewName)) {\n\t\t\treturn responseBody.render(viewName, error);\n\t\t}\n\t\tResource resource = resolveResource(viewName);\n\t\tif (resource != null) {\n\t\t\treturn responseBody.body(BodyInserters.fromResource(resource));\n\t\t}\n\t\treturn Mono.empty();\n\t}"
"protected Mono<ServerResponse> renderDefaultErrorView(\n\t\t\tServerResponse.BodyBuilder responseBody, Map<String, Object> error) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tDate timestamp = (Date) error.get(\"timestamp\");\n\t\tObject message = error.get(\"message\");\n\t\tObject trace = error.get(\"trace\");\n\t\tObject requestId = error.get(\"requestId\");\n\t\tbuilder.append(\"<html><body><h1>Whitelabel Error Page</h1>\").append(\n\t\t\t\t\"<p>This application has no configured error view, so you are seeing this as a fallback.</p>\")\n\t\t\t\t.append(\"<div id='created'>\").append(timestamp).append(\"</div>\")\n\t\t\t\t.append(\"<div>[\").append(requestId)\n\t\t\t\t.append(\"] There was an unexpected error (type=\")\n\t\t\t\t.append(htmlEscape(error.get(\"error\"))).append(\", status=\")\n\t\t\t\t.append(htmlEscape(error.get(\"status\"))).append(\").</div>\");\n\t\tif (message != null) {\n\t\t\tbuilder.append(\"<div>\").append(htmlEscape(message)).append(\"</div>\");\n\t\t}\n\t\tif (trace != null) {\n\t\t\tbuilder.append(\"<div style='white-space:pre-wrap;'>\")\n\t\t\t\t\t.append(htmlEscape(trace)).append(\"</div>\");\n\t\t}\n\t\tbuilder.append(\"</body></html>\");\n\t\treturn responseBody.syncBody(builder.toString());\n\t}"
"public String readHeader() throws IOException {\n\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\tStringBuilder content = new StringBuilder(BUFFER_SIZE);\n\t\twhile (content.indexOf(HEADER_END) == -1) {\n\t\t\tint amountRead = checkedRead(buffer, 0, BUFFER_SIZE);\n\t\t\tcontent.append(new String(buffer, 0, amountRead));\n\t\t}\n\t\treturn content.substring(0, content.indexOf(HEADER_END));\n\t}"
"public void readFully(byte[] buffer, int offset, int length) throws IOException {\n\t\twhile (length > 0) {\n\t\t\tint amountRead = checkedRead(buffer, offset, length);\n\t\t\toffset += amountRead;\n\t\t\tlength -= amountRead;\n\t\t}\n\t}"
"public int checkedRead(byte[] buffer, int offset, int length) throws IOException {\n\t\tint amountRead = read(buffer, offset, length);\n\t\tif (amountRead == -1) {\n\t\t\tthrow new IOException(\"End of stream\");\n\t\t}\n\t\treturn amountRead;\n\t}"
"private String getEntityManagerFactoryName(String beanName) {\n\t\tif (beanName.length() > ENTITY_MANAGER_FACTORY_SUFFIX.length() && StringUtils\n\t\t\t\t.endsWithIgnoreCase(beanName, ENTITY_MANAGER_FACTORY_SUFFIX)) {\n\t\t\treturn beanName.substring(0,\n\t\t\t\t\tbeanName.length() - ENTITY_MANAGER_FACTORY_SUFFIX.length());\n\t\t}\n\t\treturn beanName;\n\t}"
