[{"fid": 0, "label": "1", "url": "https://github.com/microfocus-idol/java-hod-client/blob/56359e5b93a5637c37ef82ce3fc78b95cf1f6d80/src/main/java/com/hp/autonomy/hod/client/api/analysis/viewdocument/ViewDocumentRequestBuilder.java#L55-L59", "function_name": "ViewDocumentRequestBuilder.addHighlightExpressions", "nl": "Adds values to the highlight_expression parameter", "code": "public ViewDocumentRequestBuilder addHighlightExpressions ( final String highlightExpression , final String ... highlightExpressions ) { this . highlightExpressions . add ( highlightExpression ) ; this . highlightExpressions . addAll ( Arrays . asList ( highlightExpressions ) ) ; return this ; }"}, {"fid": 1, "label": "1", "url": "https://github.com/lightblueseas/xml-extensions/blob/4c79d3b2a27349cc7b682d88ce55ac06025e6612/src/main/java/de/alpharogroup/xml/tag/Tag.java#L198-L240", "function_name": "Tag.toXmlString", "nl": "Creates from this { @link Tag } object an xml string .", "code": "public String toXmlString ( ) { final StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( \"<\" ) ; buffer . append ( getName ( ) ) ; Optional < String > attr = TagExtensions . attributesToString ( getAttributes ( ) ) ; if ( attr . isPresent ( ) ) { buffer . append ( attr . get ( ) ) ; } if ( isEndTag ( ) ) { buffer . append ( \">\" ) ; if ( getChildren ( ) != null && ! getChildren ( ) . isEmpty ( ) ) { String processingContent = getContent ( ) ; Integer lastPosition = 0 ; for ( final ChildTagPosition child : getChildren ( ) ) { final String subContent = getContent ( ) . substring ( lastPosition , child . getPosition ( ) ) ; lastPosition = child . getPosition ( ) ; processingContent = processingContent . substring ( lastPosition , processingContent . length ( ) ) ; buffer . append ( subContent ) ; buffer . append ( child . getChild ( ) . toXmlString ( ) ) ; } buffer . append ( processingContent ) ; } else { buffer . append ( getContent ( ) ) ; } buffer . append ( \"</\" ) ; buffer . append ( getName ( ) ) ; buffer . append ( \">\" ) ; } else { buffer . append ( \"/>\" ) ; } return buffer . toString ( ) ; }"}, {"fid": 2, "label": "0", "url": "https://github.com/Netflix/Fenzo/blob/3c1d8fc84027900231756e5072f0e1de303772cf/fenzo-core/src/main/java/com/netflix/fenzo/TaskScheduler.java#L1247-L1250", "function_name": "TaskScheduler.getTaskAssignerIntl", "nl": "Disable the virtual machine with the specified hostname . The scheduler will not use disabled hosts for allocating resources to tasks .", "code": "Action2 < TaskRequest , String > getTaskAssignerIntl ( ) throws IllegalStateException { return ( request , hostname ) -> { try ( AutoCloseable ignored = stateMonitor . enter ( ) ) { assignableVMs . setTaskAssigned ( request , hostname ) ; } catch ( Exception e ) { logger . error ( \"Unexpected error from state monitor: \" + e . getMessage ( ) , e ) ; throw new IllegalStateException ( e ) ; } } ; }"}, {"fid": 3, "label": "1", "url": "https://github.com/nutzam/nutz/blob/a38694d5cbda2692e7931ab093c168487a6a4bfe/src/org/nutz/lang/Streams.java#L389-L398", "function_name": "Streams.safeClose", "nl": "\u5173\u95ed\u4e00\u4e2a\u53ef\u5173\u95ed\u5bf9\u8c61\uff0c\u53ef\u4ee5\u63a5\u53d7 null\u3002\u5982\u679c\u6210\u529f\u5173\u95ed\uff0c\u8fd4\u56de true\uff0c\u53d1\u751f\u5f02\u5e38 \u8fd4\u56de false", "code": "public static boolean safeClose ( Closeable cb ) { if ( null != cb ) try { cb . close ( ) ; } catch ( IOException e ) { return false ; } return true ; }"}, {"fid": 4, "label": "0", "url": "https://github.com/linkedin/Spyglass/blob/3816f2da13b75e1a20b2911d1b780b73f44e1150/spyglass/src/main/java/com/linkedin/android/spyglass/tokenization/impl/WordTokenizer.java#L218-L227", "function_name": "WordTokenizer.isExplicitChar", "nl": "{", "code": "public boolean isExplicitChar ( final char c ) { final String explicitChars = mConfig . EXPLICIT_CHARS ; for ( int i = 0 ; i < explicitChars . length ( ) ; i ++ ) { char explicitChar = explicitChars . charAt ( i ) ; if ( c == explicitChar ) { return true ; } } return false ; }"}, {"fid": 5, "label": "0", "url": "https://github.com/nhaarman/ListViewAnimations/blob/23617960178fb5af3099c07996569cc305a40945/lib-manipulation/src/main/java/com/nhaarman/listviewanimations/itemmanipulation/animateaddition/InsertQueue.java#L120-L131", "function_name": "InsertQueue.removeActiveIndex", "nl": "Inserts pending items into the Insertable and adds them to the active positions ( correctly managing position shifting ) . Clears the pending items .", "code": "public void removeActiveIndex ( final int index ) { boolean found = false ; for ( Iterator < AtomicInteger > iterator = mActiveIndexes . iterator ( ) ; iterator . hasNext ( ) && ! found ; ) { if ( iterator . next ( ) . get ( ) == index ) { iterator . remove ( ) ; found = true ; } } if ( mActiveIndexes . isEmpty ( ) ) { insertPending ( ) ; } }"}, {"fid": 6, "label": "1", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/primitives/ImmutableDoubleArray.java#L156-L158", "function_name": "ImmutableDoubleArray.copyOf", "nl": "Returns an immutable array containing the given values in order .", "code": "public static ImmutableDoubleArray copyOf ( Collection < Double > values ) { return values . isEmpty ( ) ? EMPTY : new ImmutableDoubleArray ( Doubles . toArray ( values ) ) ; }"}, {"fid": 7, "label": "0", "url": "https://github.com/robolectric/robolectric/blob/4fa79a2c72f8abbf742ab920419653c207b41d62/shadows/framework/src/main/java/org/robolectric/shadows/ResourceHelper.java#L103-L117", "function_name": "ResourceHelper.getColor", "nl": "Returns the TypedValue color type represented by the given string value", "code": "public static int getColor ( String value ) { if ( value != null ) { if ( value . startsWith ( \"#\" ) == false ) { throw new NumberFormatException ( String . format ( \"Color value '%s' must start with #\" , value ) ) ; } value = value . substring ( 1 ) ; // make sure it's not longer than 32bit if ( value . length ( ) > 8 ) { throw new NumberFormatException ( String . format ( \"Color value '%s' is too long. Format is either\" + \"#AARRGGBB, #RRGGBB, #RGB, or #ARGB\" , value ) ) ; } if ( value . length ( ) == 3 ) { // RGB format char [ ] color = new char [ 8 ] ; color [ 0 ] = color [ 1 ] = ' ' ; color [ 2 ] = color [ 3 ] = value . charAt ( 0 ) ; color [ 4 ] = color [ 5 ] = value . charAt ( 1 ) ; color [ 6 ] = color [ 7 ] = value . charAt ( 2 ) ; value = new String ( color ) ; } else if ( value . length ( ) == 4 ) { // ARGB format char [ ] color = new char [ 8 ] ; color [ 0 ] = color [ 1 ] = value . charAt ( 0 ) ; color [ 2 ] = color [ 3 ] = value . charAt ( 1 ) ; color [ 4 ] = color [ 5 ] = value . charAt ( 2 ) ; color [ 6 ] = color [ 7 ] = value . charAt ( 3 ) ; value = new String ( color ) ; } else if ( value . length ( ) == 6 ) { value = \"FF\" + value ; } // this is a RRGGBB or AARRGGBB value // Integer.parseInt will fail to inferFromValue strings like \"ff191919\", so we use // a Long, but cast the result back into an int, since we know that we're only // dealing with 32 bit values. return ( int ) Long . parseLong ( value , 16 ) ; } throw new NumberFormatException ( ) ; }"}, {"fid": 8, "label": "1", "url": "https://github.com/advantageous/qbit/blob/533b3671785f238d576b02b5290c6525ed60f583/qbit/core/src/main/java/io/advantageous/qbit/server/HttpRequestServiceServerHandlerUsingMetaImpl.java#L196-L237", "function_name": "HttpRequestServiceServerHandlerUsingMetaImpl.handleResponseFromServiceToHttpResponse", "nl": "2nd MOST IMPORTANT METHOD FOR DEBUGGING WHY SOMETHING IS NOT CALLED .", "code": "@ Override public void handleResponseFromServiceToHttpResponse ( final Response < Object > response , final HttpRequest originatingRequest ) { final String key = Str . add ( \"\" + originatingRequest . id ( ) , \"|\" , originatingRequest . returnAddress ( ) ) ; this . outstandingRequestMap . remove ( key ) ; if ( response . wasErrors ( ) ) { handleError ( response , originatingRequest ) ; } else { if ( response . body ( ) instanceof HttpResponse ) { writeHttpResponse ( originatingRequest . getReceiver ( ) , ( ( HttpResponse ) response . body ( ) ) ) ; } else { final RequestMetaData requestMetaData = metaDataProviderMap . get ( RequestMethod . valueOf ( originatingRequest . getMethod ( ) ) ) . get ( originatingRequest . address ( ) ) ; final ServiceMethodMeta serviceMethodMeta = requestMetaData . getMethod ( ) ; final int responseCode = serviceMethodMeta . getResponseCode ( ) ; MultiMap < String , String > headers = response . headers ( ) ; if ( requestMetaData . getRequest ( ) . hasResponseHeaders ( ) ) { if ( response . headers ( ) == MultiMap . EMPTY ) { headers = new MultiMapImpl <> ( ) ; } else { headers = response . headers ( ) ; } headers . putAllCopyLists ( requestMetaData . getRequest ( ) . getResponseHeaders ( ) ) ; } writeResponse ( originatingRequest . getReceiver ( ) , responseCode == - 1 ? HttpStatus . OK : responseCode , serviceMethodMeta . getContentType ( ) , jsonMapper . toJson ( response . body ( ) ) , headers ) ; } } }"}, {"fid": 9, "label": "1", "url": "https://github.com/camunda-consulting/code/blob/11f89fbfcca7c8847fefc724cc65ee4de048f61d/snippets/four-eyes-advanced/four-eyes-advanced-process-engine-plugin/src/main/java/org/camunda/bpm/examples/FourEyesExtensionsParseListener.java#L48-L70", "function_name": "FourEyesExtensionsParseListener.addFourEyesTaskListener", "nl": "Add TaskListener on complete event generically every time so we don t have to add it in the XML .", "code": "private void addFourEyesTaskListener ( ActivityImpl activity ) { UserTaskActivityBehavior userTaskActivityBehavior = ( UserTaskActivityBehavior ) activity . getActivityBehavior ( ) ; boolean listenerAlreadyExists = false ; // check that the listener wasn't added in the XML explicitly List < TaskListener > existingListeners = userTaskActivityBehavior . getTaskDefinition ( ) . getTaskListeners ( ) . get ( \"complete\" ) ; for ( TaskListener taskListener : existingListeners ) { if ( taskListener instanceof ClassDelegate && ( ( ClassDelegate ) taskListener ) . getClassName ( ) . equals ( TaskCompletionListener . class . getName ( ) ) ) { listenerAlreadyExists = true ; logger . info ( TaskCompletionListener . class . getSimpleName ( ) + \" was already explicitly added to usertask in the bpmn xml.\" ) ; break ; } } if ( ! listenerAlreadyExists ) { logger . info ( \"Adding \" + TaskCompletionListener . class . getSimpleName ( ) + \" implicitly to usertask.\" ) ; ClassDelegate taskListener = new ClassDelegate ( TaskCompletionListener . class , null ) ; userTaskActivityBehavior . getTaskDefinition ( ) . addTaskListener ( \"complete\" , taskListener ) ; } }"}]