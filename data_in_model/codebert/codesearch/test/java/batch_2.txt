1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>Wraps an ObservableSource into an Observable if not already an Observable .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>Wraps an ObservableSource into an Observable if not already an Observable .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count ) { return buffer ( count , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>Wraps an ObservableSource into an Observable if not already an Observable .<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concat ( Iterable < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , bufferSize ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>Wraps an ObservableSource into an Observable if not already an Observable .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing > Observable < List < T > > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator ) { return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>Wraps an ObservableSource into an Observable if not already an Observable .<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , final Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableToList ( sources , 16 ) . flatMap ( ObservableInternalHelper . zipIterable ( zipper ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>Wraps an ObservableSource into an Observable if not already an Observable .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > ambWith ( ObservableSource < ? extends T > other ) { ObjectHelper . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>Wraps an ObservableSource into an Observable if not already an Observable .<CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayDelayError ( ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } else if ( sources . length == 1 ) { return ( Observable < T > ) wrap ( sources [ 0 ] ) ; } return concatDelayError ( fromArray ( sources ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>Wraps an ObservableSource into an Observable if not already an Observable .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingleDelayError ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , boolean tillTheEnd ) { return concatMapSingleDelayError ( mapper , tillTheEnd , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>Wraps an ObservableSource into an Observable if not already an Observable .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; if ( this instanceof ScalarCallable ) { @ SuppressWarnings ( "unchecked" ) T v = ( ( ScalarCallable < T > ) this ) . call ( ) ; if ( v == null ) { return empty ( ) ; } return ObservableScalarXMap . scalarXMap ( v , mapper ) ; } return RxJavaPlugins . onAssembly ( new ObservableConcatMap < T , R > ( this , mapper , prefetch , ErrorMode . IMMEDIATE ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>Wraps an ObservableSource into an Observable if not already an Observable .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( Callable < ? extends ObservableSource < B > > boundarySupplier ) { return buffer ( boundarySupplier , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count ) { return buffer ( count , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concat ( Iterable < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , bufferSize ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing > Observable < List < T > > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator ) { return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , final Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableToList ( sources , 16 ) . flatMap ( ObservableInternalHelper . zipIterable ( zipper ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > ambWith ( ObservableSource < ? extends T > other ) { ObjectHelper . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayDelayError ( ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } else if ( sources . length == 1 ) { return ( Observable < T > ) wrap ( sources [ 0 ] ) ; } return concatDelayError ( fromArray ( sources ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingleDelayError ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , boolean tillTheEnd ) { return concatMapSingleDelayError ( mapper , tillTheEnd , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; if ( this instanceof ScalarCallable ) { @ SuppressWarnings ( "unchecked" ) T v = ( ( ScalarCallable < T > ) this ) . call ( ) ; if ( v == null ) { return empty ( ) ; } return ObservableScalarXMap . scalarXMap ( v , mapper ) ; } return RxJavaPlugins . onAssembly ( new ObservableConcatMap < T , R > ( this , mapper , prefetch , ErrorMode . IMMEDIATE ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( Callable < ? extends ObservableSource < B > > boundarySupplier ) { return buffer ( boundarySupplier , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concat . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concat . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count ) { return buffer ( count , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concat . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concat ( Iterable < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , bufferSize ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concat . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing > Observable < List < T > > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator ) { return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concat . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , final Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableToList ( sources , 16 ) . flatMap ( ObservableInternalHelper . zipIterable ( zipper ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concat . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > ambWith ( ObservableSource < ? extends T > other ) { ObjectHelper . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concat . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayDelayError ( ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } else if ( sources . length == 1 ) { return ( Observable < T > ) wrap ( sources [ 0 ] ) ; } return concatDelayError ( fromArray ( sources ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concat . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingleDelayError ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , boolean tillTheEnd ) { return concatMapSingleDelayError ( mapper , tillTheEnd , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concat . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; if ( this instanceof ScalarCallable ) { @ SuppressWarnings ( "unchecked" ) T v = ( ( ScalarCallable < T > ) this ) . call ( ) ; if ( v == null ) { return empty ( ) ; } return ObservableScalarXMap . scalarXMap ( v , mapper ) ; } return RxJavaPlugins . onAssembly ( new ObservableConcatMap < T , R > ( this , mapper , prefetch , ErrorMode . IMMEDIATE ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concat . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( Callable < ? extends ObservableSource < B > > boundarySupplier ) { return buffer ( boundarySupplier , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count ) { return buffer ( count , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concat ( Iterable < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , bufferSize ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing > Observable < List < T > > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator ) { return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , final Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableToList ( sources , 16 ) . flatMap ( ObservableInternalHelper . zipIterable ( zipper ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > ambWith ( ObservableSource < ? extends T > other ) { ObjectHelper . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayDelayError ( ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } else if ( sources . length == 1 ) { return ( Observable < T > ) wrap ( sources [ 0 ] ) ; } return concatDelayError ( fromArray ( sources ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingleDelayError ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , boolean tillTheEnd ) { return concatMapSingleDelayError ( mapper , tillTheEnd , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; if ( this instanceof ScalarCallable ) { @ SuppressWarnings ( "unchecked" ) T v = ( ( ScalarCallable < T > ) this ) . call ( ) ; if ( v == null ) { return empty ( ) ; } return ObservableScalarXMap . scalarXMap ( v , mapper ) ; } return RxJavaPlugins . onAssembly ( new ObservableConcatMap < T , R > ( this , mapper , prefetch , ErrorMode . IMMEDIATE ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( Callable < ? extends ObservableSource < B > > boundarySupplier ) { return buffer ( boundarySupplier , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of <i > n< / i > items emitted in sequence by the <i > n< / i > ObservableSources emitted by a specified ObservableSource . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the ObservableSources emitted by the source ObservableSource ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( just ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of <i > n< / i > items emitted in sequence by the <i > n< / i > ObservableSources emitted by a specified ObservableSource . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the ObservableSources emitted by the source ObservableSource ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( just ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count ) { return buffer ( count , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of <i > n< / i > items emitted in sequence by the <i > n< / i > ObservableSources emitted by a specified ObservableSource . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the ObservableSources emitted by the source ObservableSource ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( just ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concat ( Iterable < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , bufferSize ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of <i > n< / i > items emitted in sequence by the <i > n< / i > ObservableSources emitted by a specified ObservableSource . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the ObservableSources emitted by the source ObservableSource ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( just ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing > Observable < List < T > > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator ) { return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of <i > n< / i > items emitted in sequence by the <i > n< / i > ObservableSources emitted by a specified ObservableSource . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the ObservableSources emitted by the source ObservableSource ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( just ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , final Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableToList ( sources , 16 ) . flatMap ( ObservableInternalHelper . zipIterable ( zipper ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of <i > n< / i > items emitted in sequence by the <i > n< / i > ObservableSources emitted by a specified ObservableSource . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the ObservableSources emitted by the source ObservableSource ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( just ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > ambWith ( ObservableSource < ? extends T > other ) { ObjectHelper . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of <i > n< / i > items emitted in sequence by the <i > n< / i > ObservableSources emitted by a specified ObservableSource . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the ObservableSources emitted by the source ObservableSource ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( just ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayDelayError ( ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } else if ( sources . length == 1 ) { return ( Observable < T > ) wrap ( sources [ 0 ] ) ; } return concatDelayError ( fromArray ( sources ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of <i > n< / i > items emitted in sequence by the <i > n< / i > ObservableSources emitted by a specified ObservableSource . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the ObservableSources emitted by the source ObservableSource ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( just ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingleDelayError ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , boolean tillTheEnd ) { return concatMapSingleDelayError ( mapper , tillTheEnd , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of <i > n< / i > items emitted in sequence by the <i > n< / i > ObservableSources emitted by a specified ObservableSource . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the ObservableSources emitted by the source ObservableSource ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( just ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; if ( this instanceof ScalarCallable ) { @ SuppressWarnings ( "unchecked" ) T v = ( ( ScalarCallable < T > ) this ) . call ( ) ; if ( v == null ) { return empty ( ) ; } return ObservableScalarXMap . scalarXMap ( v , mapper ) ; } return RxJavaPlugins . onAssembly ( new ObservableConcatMap < T , R > ( this , mapper , prefetch , ErrorMode . IMMEDIATE ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of <i > n< / i > items emitted in sequence by the <i > n< / i > ObservableSources emitted by a specified ObservableSource . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the ObservableSources emitted by the source ObservableSource ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( just ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( Callable < ? extends ObservableSource < B > > boundarySupplier ) { return buffer ( boundarySupplier , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>Mirrors the ObservableSource ( current or provided ) that first either emits an item or sends a termination notification . <p > <img width = 640 height = 385 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / ambWith . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code ambWith } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>Mirrors the ObservableSource ( current or provided ) that first either emits an item or sends a termination notification . <p > <img width = 640 height = 385 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / ambWith . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code ambWith } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count ) { return buffer ( count , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>Mirrors the ObservableSource ( current or provided ) that first either emits an item or sends a termination notification . <p > <img width = 640 height = 385 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / ambWith . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code ambWith } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concat ( Iterable < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , bufferSize ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>Mirrors the ObservableSource ( current or provided ) that first either emits an item or sends a termination notification . <p > <img width = 640 height = 385 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / ambWith . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code ambWith } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing > Observable < List < T > > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator ) { return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>Mirrors the ObservableSource ( current or provided ) that first either emits an item or sends a termination notification . <p > <img width = 640 height = 385 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / ambWith . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code ambWith } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , final Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableToList ( sources , 16 ) . flatMap ( ObservableInternalHelper . zipIterable ( zipper ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>Mirrors the ObservableSource ( current or provided ) that first either emits an item or sends a termination notification . <p > <img width = 640 height = 385 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / ambWith . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code ambWith } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > ambWith ( ObservableSource < ? extends T > other ) { ObjectHelper . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>Mirrors the ObservableSource ( current or provided ) that first either emits an item or sends a termination notification . <p > <img width = 640 height = 385 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / ambWith . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code ambWith } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayDelayError ( ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } else if ( sources . length == 1 ) { return ( Observable < T > ) wrap ( sources [ 0 ] ) ; } return concatDelayError ( fromArray ( sources ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>Mirrors the ObservableSource ( current or provided ) that first either emits an item or sends a termination notification . <p > <img width = 640 height = 385 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / ambWith . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code ambWith } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingleDelayError ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , boolean tillTheEnd ) { return concatMapSingleDelayError ( mapper , tillTheEnd , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>Mirrors the ObservableSource ( current or provided ) that first either emits an item or sends a termination notification . <p > <img width = 640 height = 385 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / ambWith . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code ambWith } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; if ( this instanceof ScalarCallable ) { @ SuppressWarnings ( "unchecked" ) T v = ( ( ScalarCallable < T > ) this ) . call ( ) ; if ( v == null ) { return empty ( ) ; } return ObservableScalarXMap . scalarXMap ( v , mapper ) ; } return RxJavaPlugins . onAssembly ( new ObservableConcatMap < T , R > ( this , mapper , prefetch , ErrorMode . IMMEDIATE ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>Mirrors the ObservableSource ( current or provided ) that first either emits an item or sends a termination notification . <p > <img width = 640 height = 385 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / ambWith . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code ambWith } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( Callable < ? extends ObservableSource < B > > boundarySupplier ) { return buffer ( boundarySupplier , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>Concatenates a variable number of ObservableSource sources and delays errors from any of them till all terminate . <p > <img width = 640 height = 290 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatArray . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>Concatenates a variable number of ObservableSource sources and delays errors from any of them till all terminate . <p > <img width = 640 height = 290 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatArray . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count ) { return buffer ( count , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>Concatenates a variable number of ObservableSource sources and delays errors from any of them till all terminate . <p > <img width = 640 height = 290 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatArray . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concat ( Iterable < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , bufferSize ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>Concatenates a variable number of ObservableSource sources and delays errors from any of them till all terminate . <p > <img width = 640 height = 290 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatArray . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing > Observable < List < T > > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator ) { return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>Concatenates a variable number of ObservableSource sources and delays errors from any of them till all terminate . <p > <img width = 640 height = 290 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatArray . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , final Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableToList ( sources , 16 ) . flatMap ( ObservableInternalHelper . zipIterable ( zipper ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>Concatenates a variable number of ObservableSource sources and delays errors from any of them till all terminate . <p > <img width = 640 height = 290 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatArray . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > ambWith ( ObservableSource < ? extends T > other ) { ObjectHelper . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>Concatenates a variable number of ObservableSource sources and delays errors from any of them till all terminate . <p > <img width = 640 height = 290 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatArray . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayDelayError ( ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } else if ( sources . length == 1 ) { return ( Observable < T > ) wrap ( sources [ 0 ] ) ; } return concatDelayError ( fromArray ( sources ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>Concatenates a variable number of ObservableSource sources and delays errors from any of them till all terminate . <p > <img width = 640 height = 290 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatArray . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingleDelayError ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , boolean tillTheEnd ) { return concatMapSingleDelayError ( mapper , tillTheEnd , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>Concatenates a variable number of ObservableSource sources and delays errors from any of them till all terminate . <p > <img width = 640 height = 290 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatArray . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; if ( this instanceof ScalarCallable ) { @ SuppressWarnings ( "unchecked" ) T v = ( ( ScalarCallable < T > ) this ) . call ( ) ; if ( v == null ) { return empty ( ) ; } return ObservableScalarXMap . scalarXMap ( v , mapper ) ; } return RxJavaPlugins . onAssembly ( new ObservableConcatMap < T , R > ( this , mapper , prefetch , ErrorMode . IMMEDIATE ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>Concatenates a variable number of ObservableSource sources and delays errors from any of them till all terminate . <p > <img width = 640 height = 290 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatArray . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( Callable < ? extends ObservableSource < B > > boundarySupplier ) { return buffer ( boundarySupplier , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count ) { return buffer ( count , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concat ( Iterable < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , bufferSize ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing > Observable < List < T > > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator ) { return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , final Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableToList ( sources , 16 ) . flatMap ( ObservableInternalHelper . zipIterable ( zipper ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > ambWith ( ObservableSource < ? extends T > other ) { ObjectHelper . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayDelayError ( ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } else if ( sources . length == 1 ) { return ( Observable < T > ) wrap ( sources [ 0 ] ) ; } return concatDelayError ( fromArray ( sources ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingleDelayError ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , boolean tillTheEnd ) { return concatMapSingleDelayError ( mapper , tillTheEnd , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; if ( this instanceof ScalarCallable ) { @ SuppressWarnings ( "unchecked" ) T v = ( ( ScalarCallable < T > ) this ) . call ( ) ; if ( v == null ) { return empty ( ) ; } return ObservableScalarXMap . scalarXMap ( v , mapper ) ; } return RxJavaPlugins . onAssembly ( new ObservableConcatMap < T , R > ( this , mapper , prefetch , ErrorMode . IMMEDIATE ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( Callable < ? extends ObservableSource < B > > boundarySupplier ) { return buffer ( boundarySupplier , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count ) { return buffer ( count , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concat ( Iterable < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , bufferSize ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing > Observable < List < T > > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator ) { return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , final Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableToList ( sources , 16 ) . flatMap ( ObservableInternalHelper . zipIterable ( zipper ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > ambWith ( ObservableSource < ? extends T > other ) { ObjectHelper . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayDelayError ( ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } else if ( sources . length == 1 ) { return ( Observable < T > ) wrap ( sources [ 0 ] ) ; } return concatDelayError ( fromArray ( sources ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingleDelayError ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , boolean tillTheEnd ) { return concatMapSingleDelayError ( mapper , tillTheEnd , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; if ( this instanceof ScalarCallable ) { @ SuppressWarnings ( "unchecked" ) T v = ( ( ScalarCallable < T > ) this ) . call ( ) ; if ( v == null ) { return empty ( ) ; } return ObservableScalarXMap . scalarXMap ( v , mapper ) ; } return RxJavaPlugins . onAssembly ( new ObservableConcatMap < T , R > ( this , mapper , prefetch , ErrorMode . IMMEDIATE ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( Callable < ? extends ObservableSource < B > > boundarySupplier ) { return buffer ( boundarySupplier , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers . It emits the current buffer and replaces it with a new buffer whenever the ObservableSource produced by the specified { @code boundarySupplier } emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer1 . png alt = > <p > If either the source { @code ObservableSource } or the boundary { @code ObservableSource } issues an { @code onError } notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5574-L5578<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers . It emits the current buffer and replaces it with a new buffer whenever the ObservableSource produced by the specified { @code boundarySupplier } emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer1 . png alt = > <p > If either the source { @code ObservableSource } or the boundary { @code ObservableSource } issues an { @code onError } notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count ) { return buffer ( count , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1099-L1106<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers . It emits the current buffer and replaces it with a new buffer whenever the ObservableSource produced by the specified { @code boundarySupplier } emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer1 . png alt = > <p > If either the source { @code ObservableSource } or the boundary { @code ObservableSource } issues an { @code onError } notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concat ( Iterable < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , bufferSize ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5978-L5984<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers . It emits the current buffer and replaces it with a new buffer whenever the ObservableSource produced by the specified { @code boundarySupplier } emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer1 . png alt = > <p > If either the source { @code ObservableSource } or the boundary { @code ObservableSource } issues an { @code onError } notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing > Observable < List < T > > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator ) { return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4190-L4198<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers . It emits the current buffer and replaces it with a new buffer whenever the ObservableSource produced by the specified { @code boundarySupplier } emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer1 . png alt = > <p > If either the source { @code ObservableSource } or the boundary { @code ObservableSource } issues an { @code onError } notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , final Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableToList ( sources , 16 ) . flatMap ( ObservableInternalHelper . zipIterable ( zipper ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5044-L5050<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers . It emits the current buffer and replaces it with a new buffer whenever the ObservableSource produced by the specified { @code boundarySupplier } emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer1 . png alt = > <p > If either the source { @code ObservableSource } or the boundary { @code ObservableSource } issues an { @code onError } notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > ambWith ( ObservableSource < ? extends T > other ) { ObjectHelper . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1302-L1313<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers . It emits the current buffer and replaces it with a new buffer whenever the ObservableSource produced by the specified { @code boundarySupplier } emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer1 . png alt = > <p > If either the source { @code ObservableSource } or the boundary { @code ObservableSource } issues an { @code onError } notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayDelayError ( ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } else if ( sources . length == 1 ) { return ( Observable < T > ) wrap ( sources [ 0 ] ) ; } return concatDelayError ( fromArray ( sources ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7121-L7125<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers . It emits the current buffer and replaces it with a new buffer whenever the ObservableSource produced by the specified { @code boundarySupplier } emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer1 . png alt = > <p > If either the source { @code ObservableSource } or the boundary { @code ObservableSource } issues an { @code onError } notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingleDelayError ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , boolean tillTheEnd ) { return concatMapSingleDelayError ( mapper , tillTheEnd , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6466-L6480<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers . It emits the current buffer and replaces it with a new buffer whenever the ObservableSource produced by the specified { @code boundarySupplier } emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer1 . png alt = > <p > If either the source { @code ObservableSource } or the boundary { @code ObservableSource } issues an { @code onError } notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; if ( this instanceof ScalarCallable ) { @ SuppressWarnings ( "unchecked" ) T v = ( ( ScalarCallable < T > ) this ) . call ( ) ; if ( v == null ) { return empty ( ) ; } return ObservableScalarXMap . scalarXMap ( v , mapper ) ; } return RxJavaPlugins . onAssembly ( new ObservableConcatMap < T , R > ( this , mapper , prefetch , ErrorMode . IMMEDIATE ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6148-L6152<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers . It emits the current buffer and replaces it with a new buffer whenever the ObservableSource produced by the specified { @code boundarySupplier } emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer1 . png alt = > <p > If either the source { @code ObservableSource } or the boundary { @code ObservableSource } issues an { @code onError } notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( Callable < ? extends ObservableSource < B > > boundarySupplier ) { return buffer ( boundarySupplier , ArrayListSupplier . < T > asCallable ( ) ) ; }