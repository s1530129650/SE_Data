1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 394 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . png alt = > <p > Note that calling this method will block the caller thread until the upstream terminates normally or with an error . Therefore calling this method from special threads such as the Android Main Thread or the Swing Event Dispatch Thread is not recommended . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext , Consumer < ? super Throwable > onError , Action onComplete ) { ObservableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 394 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . png alt = > <p > Note that calling this method will block the caller thread until the upstream terminates normally or with an error . Therefore calling this method from special threads such as the Android Main Thread or the Swing Event Dispatch Thread is not recommended . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > compose ( ObservableTransformer < ? super T , ? extends R > composer ) { return wrap ( ( ( ObservableTransformer < T , R > ) ObjectHelper . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 394 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . png alt = > <p > Note that calling this method will block the caller thread until the upstream terminates normally or with an error . Therefore calling this method from special threads such as the Android Main Thread or the Swing Event Dispatch Thread is not recommended . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletableDelayError ( Function < ? super T , ? extends CompletableSource > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 394 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . png alt = > <p > Note that calling this method will block the caller thread until the upstream terminates normally or with an error . Therefore calling this method from special threads such as the Android Main Thread or the Swing Event Dispatch Thread is not recommended . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . COMPUTATION ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , int count ) { return buffer ( timespan , unit , Schedulers . computation ( ) , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 394 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . png alt = > <p > Note that calling this method will block the caller thread until the upstream terminates normally or with an error . Therefore calling this method from special threads such as the Android Main Thread or the Swing Event Dispatch Thread is not recommended . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingForEach ( Consumer < ? super T > onNext ) { Iterator < T > it = blockingIterable ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { try { onNext . accept ( it . next ( ) ) ; } catch ( Throwable e ) { Exceptions . throwIfFatal ( e ) ; ( ( Disposable ) it ) . dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( e ) ; } } }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 394 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . png alt = > <p > Note that calling this method will block the caller thread until the upstream terminates normally or with an error . Therefore calling this method from special threads such as the Android Main Thread or the Swing Event Dispatch Thread is not recommended . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > merge ( Iterable < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int bufferSize ) { return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , false , maxConcurrency , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 394 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . png alt = > <p > Note that calling this method will block the caller thread until the upstream terminates normally or with an error . Therefore calling this method from special threads such as the Android Main Thread or the Swing Event Dispatch Thread is not recommended . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ BackpressureSupport ( BackpressureKind . UNBOUNDED_IN ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > fromPublisher ( Publisher < ? extends T > publisher ) { ObjectHelper . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < T > ( publisher ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 394 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . png alt = > <p > Note that calling this method will block the caller thread until the upstream terminates normally or with an error . Therefore calling this method from special threads such as the Android Main Thread or the Swing Event Dispatch Thread is not recommended . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final T blockingSingle ( T defaultItem ) { return single ( defaultItem ) . blockingGet ( ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 394 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . png alt = > <p > Note that calling this method will block the caller thread until the upstream terminates normally or with an error . Therefore calling this method from special threads such as the Android Main Thread or the Swing Event Dispatch Thread is not recommended . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count , int skip ) { return buffer ( count , skip , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 394 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . png alt = > <p > Note that calling this method will block the caller thread until the upstream terminates normally or with an error . Therefore calling this method from special threads such as the Android Main Thread or the Swing Event Dispatch Thread is not recommended . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( ObservableSource < B > boundary , final int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return buffer ( boundary , Functions . < T > createArrayList ( initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>Transform an ObservableSource by applying a particular Transformer function to it . <p > This method operates on the ObservableSource itself whereas { @link #lift } operates on the ObservableSource s Observers . <p > If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource use { @link #lift } . If your operator is designed to transform the source ObservableSource as a whole ( for instance by applying a particular set of existing RxJava operators to it ) use { @code compose } . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code compose } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext , Consumer < ? super Throwable > onError , Action onComplete ) { ObservableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>Transform an ObservableSource by applying a particular Transformer function to it . <p > This method operates on the ObservableSource itself whereas { @link #lift } operates on the ObservableSource s Observers . <p > If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource use { @link #lift } . If your operator is designed to transform the source ObservableSource as a whole ( for instance by applying a particular set of existing RxJava operators to it ) use { @code compose } . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code compose } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > compose ( ObservableTransformer < ? super T , ? extends R > composer ) { return wrap ( ( ( ObservableTransformer < T , R > ) ObjectHelper . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>Transform an ObservableSource by applying a particular Transformer function to it . <p > This method operates on the ObservableSource itself whereas { @link #lift } operates on the ObservableSource s Observers . <p > If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource use { @link #lift } . If your operator is designed to transform the source ObservableSource as a whole ( for instance by applying a particular set of existing RxJava operators to it ) use { @code compose } . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code compose } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletableDelayError ( Function < ? super T , ? extends CompletableSource > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>Transform an ObservableSource by applying a particular Transformer function to it . <p > This method operates on the ObservableSource itself whereas { @link #lift } operates on the ObservableSource s Observers . <p > If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource use { @link #lift } . If your operator is designed to transform the source ObservableSource as a whole ( for instance by applying a particular set of existing RxJava operators to it ) use { @code compose } . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code compose } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . COMPUTATION ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , int count ) { return buffer ( timespan , unit , Schedulers . computation ( ) , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>Transform an ObservableSource by applying a particular Transformer function to it . <p > This method operates on the ObservableSource itself whereas { @link #lift } operates on the ObservableSource s Observers . <p > If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource use { @link #lift } . If your operator is designed to transform the source ObservableSource as a whole ( for instance by applying a particular set of existing RxJava operators to it ) use { @code compose } . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code compose } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingForEach ( Consumer < ? super T > onNext ) { Iterator < T > it = blockingIterable ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { try { onNext . accept ( it . next ( ) ) ; } catch ( Throwable e ) { Exceptions . throwIfFatal ( e ) ; ( ( Disposable ) it ) . dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( e ) ; } } }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>Transform an ObservableSource by applying a particular Transformer function to it . <p > This method operates on the ObservableSource itself whereas { @link #lift } operates on the ObservableSource s Observers . <p > If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource use { @link #lift } . If your operator is designed to transform the source ObservableSource as a whole ( for instance by applying a particular set of existing RxJava operators to it ) use { @code compose } . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code compose } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > merge ( Iterable < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int bufferSize ) { return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , false , maxConcurrency , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>Transform an ObservableSource by applying a particular Transformer function to it . <p > This method operates on the ObservableSource itself whereas { @link #lift } operates on the ObservableSource s Observers . <p > If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource use { @link #lift } . If your operator is designed to transform the source ObservableSource as a whole ( for instance by applying a particular set of existing RxJava operators to it ) use { @code compose } . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code compose } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ BackpressureSupport ( BackpressureKind . UNBOUNDED_IN ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > fromPublisher ( Publisher < ? extends T > publisher ) { ObjectHelper . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < T > ( publisher ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>Transform an ObservableSource by applying a particular Transformer function to it . <p > This method operates on the ObservableSource itself whereas { @link #lift } operates on the ObservableSource s Observers . <p > If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource use { @link #lift } . If your operator is designed to transform the source ObservableSource as a whole ( for instance by applying a particular set of existing RxJava operators to it ) use { @code compose } . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code compose } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final T blockingSingle ( T defaultItem ) { return single ( defaultItem ) . blockingGet ( ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>Transform an ObservableSource by applying a particular Transformer function to it . <p > This method operates on the ObservableSource itself whereas { @link #lift } operates on the ObservableSource s Observers . <p > If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource use { @link #lift } . If your operator is designed to transform the source ObservableSource as a whole ( for instance by applying a particular set of existing RxJava operators to it ) use { @code compose } . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code compose } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count , int skip ) { return buffer ( count , skip , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>Transform an ObservableSource by applying a particular Transformer function to it . <p > This method operates on the ObservableSource itself whereas { @link #lift } operates on the ObservableSource s Observers . <p > If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource use { @link #lift } . If your operator is designed to transform the source ObservableSource as a whole ( for instance by applying a particular set of existing RxJava operators to it ) use { @code compose } . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code compose } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( ObservableSource < B > boundary , final int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return buffer ( boundary , Functions . < T > createArrayList ( initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext , Consumer < ? super Throwable > onError , Action onComplete ) { ObservableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > compose ( ObservableTransformer < ? super T , ? extends R > composer ) { return wrap ( ( ( ObservableTransformer < T , R > ) ObjectHelper . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletableDelayError ( Function < ? super T , ? extends CompletableSource > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . COMPUTATION ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , int count ) { return buffer ( timespan , unit , Schedulers . computation ( ) , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingForEach ( Consumer < ? super T > onNext ) { Iterator < T > it = blockingIterable ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { try { onNext . accept ( it . next ( ) ) ; } catch ( Throwable e ) { Exceptions . throwIfFatal ( e ) ; ( ( Disposable ) it ) . dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( e ) ; } } }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > merge ( Iterable < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int bufferSize ) { return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , false , maxConcurrency , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ BackpressureSupport ( BackpressureKind . UNBOUNDED_IN ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > fromPublisher ( Publisher < ? extends T > publisher ) { ObjectHelper . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < T > ( publisher ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final T blockingSingle ( T defaultItem ) { return single ( defaultItem ) . blockingGet ( ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count , int skip ) { return buffer ( count , skip , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( ObservableSource < B > boundary , final int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return buffer ( boundary , Functions . < T > createArrayList ( initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } operates by default on the { @code computation } { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext , Consumer < ? super Throwable > onError , Action onComplete ) { ObservableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } operates by default on the { @code computation } { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > compose ( ObservableTransformer < ? super T , ? extends R > composer ) { return wrap ( ( ( ObservableTransformer < T , R > ) ObjectHelper . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } operates by default on the { @code computation } { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletableDelayError ( Function < ? super T , ? extends CompletableSource > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } operates by default on the { @code computation } { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . COMPUTATION ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , int count ) { return buffer ( timespan , unit , Schedulers . computation ( ) , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } operates by default on the { @code computation } { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingForEach ( Consumer < ? super T > onNext ) { Iterator < T > it = blockingIterable ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { try { onNext . accept ( it . next ( ) ) ; } catch ( Throwable e ) { Exceptions . throwIfFatal ( e ) ; ( ( Disposable ) it ) . dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( e ) ; } } }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } operates by default on the { @code computation } { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > merge ( Iterable < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int bufferSize ) { return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , false , maxConcurrency , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } operates by default on the { @code computation } { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ BackpressureSupport ( BackpressureKind . UNBOUNDED_IN ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > fromPublisher ( Publisher < ? extends T > publisher ) { ObjectHelper . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < T > ( publisher ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } operates by default on the { @code computation } { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final T blockingSingle ( T defaultItem ) { return single ( defaultItem ) . blockingGet ( ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } operates by default on the { @code computation } { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count , int skip ) { return buffer ( count , skip , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } operates by default on the { @code computation } { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( ObservableSource < B > boundary , final int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return buffer ( boundary , Functions . < T > createArrayList ( initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>Consumes the upstream { @code Observable } in a blocking fashion and invokes the given { @code Consumer } with each upstream item on the <em > current thread< / em > until the upstream terminates . <p > <img width = 640 height = 330 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingForEach . o . png alt = > <p > <em > Note : < / em > the method will only return if the upstream terminates or the current thread is interrupted . <p > This method executes the { @code Consumer } on the current thread while { @link #subscribe ( Consumer ) } executes the consumer on the original caller thread of the sequence . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingForEach } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext , Consumer < ? super Throwable > onError , Action onComplete ) { ObservableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>Consumes the upstream { @code Observable } in a blocking fashion and invokes the given { @code Consumer } with each upstream item on the <em > current thread< / em > until the upstream terminates . <p > <img width = 640 height = 330 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingForEach . o . png alt = > <p > <em > Note : < / em > the method will only return if the upstream terminates or the current thread is interrupted . <p > This method executes the { @code Consumer } on the current thread while { @link #subscribe ( Consumer ) } executes the consumer on the original caller thread of the sequence . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingForEach } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > compose ( ObservableTransformer < ? super T , ? extends R > composer ) { return wrap ( ( ( ObservableTransformer < T , R > ) ObjectHelper . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>Consumes the upstream { @code Observable } in a blocking fashion and invokes the given { @code Consumer } with each upstream item on the <em > current thread< / em > until the upstream terminates . <p > <img width = 640 height = 330 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingForEach . o . png alt = > <p > <em > Note : < / em > the method will only return if the upstream terminates or the current thread is interrupted . <p > This method executes the { @code Consumer } on the current thread while { @link #subscribe ( Consumer ) } executes the consumer on the original caller thread of the sequence . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingForEach } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletableDelayError ( Function < ? super T , ? extends CompletableSource > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>Consumes the upstream { @code Observable } in a blocking fashion and invokes the given { @code Consumer } with each upstream item on the <em > current thread< / em > until the upstream terminates . <p > <img width = 640 height = 330 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingForEach . o . png alt = > <p > <em > Note : < / em > the method will only return if the upstream terminates or the current thread is interrupted . <p > This method executes the { @code Consumer } on the current thread while { @link #subscribe ( Consumer ) } executes the consumer on the original caller thread of the sequence . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingForEach } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . COMPUTATION ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , int count ) { return buffer ( timespan , unit , Schedulers . computation ( ) , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>Consumes the upstream { @code Observable } in a blocking fashion and invokes the given { @code Consumer } with each upstream item on the <em > current thread< / em > until the upstream terminates . <p > <img width = 640 height = 330 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingForEach . o . png alt = > <p > <em > Note : < / em > the method will only return if the upstream terminates or the current thread is interrupted . <p > This method executes the { @code Consumer } on the current thread while { @link #subscribe ( Consumer ) } executes the consumer on the original caller thread of the sequence . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingForEach } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingForEach ( Consumer < ? super T > onNext ) { Iterator < T > it = blockingIterable ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { try { onNext . accept ( it . next ( ) ) ; } catch ( Throwable e ) { Exceptions . throwIfFatal ( e ) ; ( ( Disposable ) it ) . dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( e ) ; } } }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>Consumes the upstream { @code Observable } in a blocking fashion and invokes the given { @code Consumer } with each upstream item on the <em > current thread< / em > until the upstream terminates . <p > <img width = 640 height = 330 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingForEach . o . png alt = > <p > <em > Note : < / em > the method will only return if the upstream terminates or the current thread is interrupted . <p > This method executes the { @code Consumer } on the current thread while { @link #subscribe ( Consumer ) } executes the consumer on the original caller thread of the sequence . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingForEach } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > merge ( Iterable < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int bufferSize ) { return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , false , maxConcurrency , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>Consumes the upstream { @code Observable } in a blocking fashion and invokes the given { @code Consumer } with each upstream item on the <em > current thread< / em > until the upstream terminates . <p > <img width = 640 height = 330 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingForEach . o . png alt = > <p > <em > Note : < / em > the method will only return if the upstream terminates or the current thread is interrupted . <p > This method executes the { @code Consumer } on the current thread while { @link #subscribe ( Consumer ) } executes the consumer on the original caller thread of the sequence . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingForEach } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ BackpressureSupport ( BackpressureKind . UNBOUNDED_IN ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > fromPublisher ( Publisher < ? extends T > publisher ) { ObjectHelper . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < T > ( publisher ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>Consumes the upstream { @code Observable } in a blocking fashion and invokes the given { @code Consumer } with each upstream item on the <em > current thread< / em > until the upstream terminates . <p > <img width = 640 height = 330 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingForEach . o . png alt = > <p > <em > Note : < / em > the method will only return if the upstream terminates or the current thread is interrupted . <p > This method executes the { @code Consumer } on the current thread while { @link #subscribe ( Consumer ) } executes the consumer on the original caller thread of the sequence . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingForEach } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final T blockingSingle ( T defaultItem ) { return single ( defaultItem ) . blockingGet ( ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>Consumes the upstream { @code Observable } in a blocking fashion and invokes the given { @code Consumer } with each upstream item on the <em > current thread< / em > until the upstream terminates . <p > <img width = 640 height = 330 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingForEach . o . png alt = > <p > <em > Note : < / em > the method will only return if the upstream terminates or the current thread is interrupted . <p > This method executes the { @code Consumer } on the current thread while { @link #subscribe ( Consumer ) } executes the consumer on the original caller thread of the sequence . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingForEach } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count , int skip ) { return buffer ( count , skip , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>Consumes the upstream { @code Observable } in a blocking fashion and invokes the given { @code Consumer } with each upstream item on the <em > current thread< / em > until the upstream terminates . <p > <img width = 640 height = 330 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingForEach . o . png alt = > <p > <em > Note : < / em > the method will only return if the upstream terminates or the current thread is interrupted . <p > This method executes the { @code Consumer } on the current thread while { @link #subscribe ( Consumer ) } executes the consumer on the original caller thread of the sequence . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingForEach } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( ObservableSource < B > boundary , final int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return buffer ( boundary , Functions . < T > createArrayList ( initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>Flattens an Iterable of ObservableSources into one ObservableSource without any transformation while limiting the number of concurrent subscriptions to these ObservableSources . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( Iterable int int ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext , Consumer < ? super Throwable > onError , Action onComplete ) { ObservableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>Flattens an Iterable of ObservableSources into one ObservableSource without any transformation while limiting the number of concurrent subscriptions to these ObservableSources . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( Iterable int int ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > compose ( ObservableTransformer < ? super T , ? extends R > composer ) { return wrap ( ( ( ObservableTransformer < T , R > ) ObjectHelper . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>Flattens an Iterable of ObservableSources into one ObservableSource without any transformation while limiting the number of concurrent subscriptions to these ObservableSources . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( Iterable int int ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletableDelayError ( Function < ? super T , ? extends CompletableSource > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>Flattens an Iterable of ObservableSources into one ObservableSource without any transformation while limiting the number of concurrent subscriptions to these ObservableSources . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( Iterable int int ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . COMPUTATION ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , int count ) { return buffer ( timespan , unit , Schedulers . computation ( ) , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>Flattens an Iterable of ObservableSources into one ObservableSource without any transformation while limiting the number of concurrent subscriptions to these ObservableSources . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( Iterable int int ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingForEach ( Consumer < ? super T > onNext ) { Iterator < T > it = blockingIterable ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { try { onNext . accept ( it . next ( ) ) ; } catch ( Throwable e ) { Exceptions . throwIfFatal ( e ) ; ( ( Disposable ) it ) . dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( e ) ; } } }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>Flattens an Iterable of ObservableSources into one ObservableSource without any transformation while limiting the number of concurrent subscriptions to these ObservableSources . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( Iterable int int ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > merge ( Iterable < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int bufferSize ) { return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , false , maxConcurrency , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>Flattens an Iterable of ObservableSources into one ObservableSource without any transformation while limiting the number of concurrent subscriptions to these ObservableSources . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( Iterable int int ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ BackpressureSupport ( BackpressureKind . UNBOUNDED_IN ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > fromPublisher ( Publisher < ? extends T > publisher ) { ObjectHelper . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < T > ( publisher ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>Flattens an Iterable of ObservableSources into one ObservableSource without any transformation while limiting the number of concurrent subscriptions to these ObservableSources . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( Iterable int int ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final T blockingSingle ( T defaultItem ) { return single ( defaultItem ) . blockingGet ( ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>Flattens an Iterable of ObservableSources into one ObservableSource without any transformation while limiting the number of concurrent subscriptions to these ObservableSources . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( Iterable int int ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count , int skip ) { return buffer ( count , skip , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>Flattens an Iterable of ObservableSources into one ObservableSource without any transformation while limiting the number of concurrent subscriptions to these ObservableSources . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( Iterable int int ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( ObservableSource < B > boundary , final int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return buffer ( boundary , Functions . < T > createArrayList ( initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>Converts an arbitrary Reactive - Streams Publisher into an Observable . <p > <img width = 640 height = 344 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / fromPublisher . o . png alt = > <p > The {<CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext , Consumer < ? super Throwable > onError , Action onComplete ) { ObservableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>Converts an arbitrary Reactive - Streams Publisher into an Observable . <p > <img width = 640 height = 344 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / fromPublisher . o . png alt = > <p > The {<CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > compose ( ObservableTransformer < ? super T , ? extends R > composer ) { return wrap ( ( ( ObservableTransformer < T , R > ) ObjectHelper . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>Converts an arbitrary Reactive - Streams Publisher into an Observable . <p > <img width = 640 height = 344 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / fromPublisher . o . png alt = > <p > The {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletableDelayError ( Function < ? super T , ? extends CompletableSource > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>Converts an arbitrary Reactive - Streams Publisher into an Observable . <p > <img width = 640 height = 344 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / fromPublisher . o . png alt = > <p > The {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . COMPUTATION ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , int count ) { return buffer ( timespan , unit , Schedulers . computation ( ) , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>Converts an arbitrary Reactive - Streams Publisher into an Observable . <p > <img width = 640 height = 344 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / fromPublisher . o . png alt = > <p > The {<CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingForEach ( Consumer < ? super T > onNext ) { Iterator < T > it = blockingIterable ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { try { onNext . accept ( it . next ( ) ) ; } catch ( Throwable e ) { Exceptions . throwIfFatal ( e ) ; ( ( Disposable ) it ) . dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( e ) ; } } }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>Converts an arbitrary Reactive - Streams Publisher into an Observable . <p > <img width = 640 height = 344 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / fromPublisher . o . png alt = > <p > The {<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > merge ( Iterable < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int bufferSize ) { return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , false , maxConcurrency , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>Converts an arbitrary Reactive - Streams Publisher into an Observable . <p > <img width = 640 height = 344 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / fromPublisher . o . png alt = > <p > The {<CODESPLIT>@ BackpressureSupport ( BackpressureKind . UNBOUNDED_IN ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > fromPublisher ( Publisher < ? extends T > publisher ) { ObjectHelper . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < T > ( publisher ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>Converts an arbitrary Reactive - Streams Publisher into an Observable . <p > <img width = 640 height = 344 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / fromPublisher . o . png alt = > <p > The {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final T blockingSingle ( T defaultItem ) { return single ( defaultItem ) . blockingGet ( ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>Converts an arbitrary Reactive - Streams Publisher into an Observable . <p > <img width = 640 height = 344 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / fromPublisher . o . png alt = > <p > The {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count , int skip ) { return buffer ( count , skip , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>Converts an arbitrary Reactive - Streams Publisher into an Observable . <p > <img width = 640 height = 344 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / fromPublisher . o . png alt = > <p > The {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( ObservableSource < B > boundary , final int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return buffer ( boundary , Functions . < T > createArrayList ( initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>If this { @code Observable } completes after emitting a single item return that item ; if it emits more than one item throw an { @code IllegalArgumentException } ; if it emits no items return a default value . <p > <img width = 640 height = 315 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingSingleDefault . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingSingle } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext , Consumer < ? super Throwable > onError , Action onComplete ) { ObservableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>If this { @code Observable } completes after emitting a single item return that item ; if it emits more than one item throw an { @code IllegalArgumentException } ; if it emits no items return a default value . <p > <img width = 640 height = 315 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingSingleDefault . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingSingle } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > compose ( ObservableTransformer < ? super T , ? extends R > composer ) { return wrap ( ( ( ObservableTransformer < T , R > ) ObjectHelper . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>If this { @code Observable } completes after emitting a single item return that item ; if it emits more than one item throw an { @code IllegalArgumentException } ; if it emits no items return a default value . <p > <img width = 640 height = 315 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingSingleDefault . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingSingle } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletableDelayError ( Function < ? super T , ? extends CompletableSource > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>If this { @code Observable } completes after emitting a single item return that item ; if it emits more than one item throw an { @code IllegalArgumentException } ; if it emits no items return a default value . <p > <img width = 640 height = 315 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingSingleDefault . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingSingle } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . COMPUTATION ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , int count ) { return buffer ( timespan , unit , Schedulers . computation ( ) , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>If this { @code Observable } completes after emitting a single item return that item ; if it emits more than one item throw an { @code IllegalArgumentException } ; if it emits no items return a default value . <p > <img width = 640 height = 315 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingSingleDefault . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingSingle } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingForEach ( Consumer < ? super T > onNext ) { Iterator < T > it = blockingIterable ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { try { onNext . accept ( it . next ( ) ) ; } catch ( Throwable e ) { Exceptions . throwIfFatal ( e ) ; ( ( Disposable ) it ) . dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( e ) ; } } }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>If this { @code Observable } completes after emitting a single item return that item ; if it emits more than one item throw an { @code IllegalArgumentException } ; if it emits no items return a default value . <p > <img width = 640 height = 315 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingSingleDefault . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingSingle } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > merge ( Iterable < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int bufferSize ) { return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , false , maxConcurrency , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>If this { @code Observable } completes after emitting a single item return that item ; if it emits more than one item throw an { @code IllegalArgumentException } ; if it emits no items return a default value . <p > <img width = 640 height = 315 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingSingleDefault . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingSingle } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ BackpressureSupport ( BackpressureKind . UNBOUNDED_IN ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > fromPublisher ( Publisher < ? extends T > publisher ) { ObjectHelper . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < T > ( publisher ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>If this { @code Observable } completes after emitting a single item return that item ; if it emits more than one item throw an { @code IllegalArgumentException } ; if it emits no items return a default value . <p > <img width = 640 height = 315 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingSingleDefault . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingSingle } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final T blockingSingle ( T defaultItem ) { return single ( defaultItem ) . blockingGet ( ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>If this { @code Observable } completes after emitting a single item return that item ; if it emits more than one item throw an { @code IllegalArgumentException } ; if it emits no items return a default value . <p > <img width = 640 height = 315 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingSingleDefault . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingSingle } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count , int skip ) { return buffer ( count , skip , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>If this { @code Observable } completes after emitting a single item return that item ; if it emits more than one item throw an { @code IllegalArgumentException } ; if it emits no items return a default value . <p > <img width = 640 height = 315 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingSingleDefault . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingSingle } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If the source signals an error the operator wraps a checked { @link Exception } into { @link RuntimeException } and throws that . Otherwise { @code RuntimeException } s and { @link Error } s are rethrown as they are . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( ObservableSource < B > boundary , final int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return buffer ( boundary , Functions . < T > createArrayList ( initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext , Consumer < ? super Throwable > onError , Action onComplete ) { ObservableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > compose ( ObservableTransformer < ? super T , ? extends R > composer ) { return wrap ( ( ( ObservableTransformer < T , R > ) ObjectHelper . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletableDelayError ( Function < ? super T , ? extends CompletableSource > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . COMPUTATION ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , int count ) { return buffer ( timespan , unit , Schedulers . computation ( ) , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingForEach ( Consumer < ? super T > onNext ) { Iterator < T > it = blockingIterable ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { try { onNext . accept ( it . next ( ) ) ; } catch ( Throwable e ) { Exceptions . throwIfFatal ( e ) ; ( ( Disposable ) it ) . dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( e ) ; } } }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > merge ( Iterable < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int bufferSize ) { return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , false , maxConcurrency , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ BackpressureSupport ( BackpressureKind . UNBOUNDED_IN ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > fromPublisher ( Publisher < ? extends T > publisher ) { ObjectHelper . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < T > ( publisher ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final T blockingSingle ( T defaultItem ) { return single ( defaultItem ) . blockingGet ( ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count , int skip ) { return buffer ( count , skip , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( ObservableSource < B > boundary , final int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return buffer ( boundary , Functions . < T > createArrayList ( initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5529-L5532<CODESPLIT>Returns an Observable that emits non - overlapping buffered items from the source ObservableSource each time the specified boundary ObservableSource emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer8 . png alt = > <p > Completion of either the source or the boundary ObservableSource causes the returned ObservableSource to emit the latest buffer and complete . If either the source ObservableSource or the boundary ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext , Consumer < ? super Throwable > onError , Action onComplete ) { ObservableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6413-L6418<CODESPLIT>Returns an Observable that emits non - overlapping buffered items from the source ObservableSource each time the specified boundary ObservableSource emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer8 . png alt = > <p > Completion of either the source or the boundary ObservableSource causes the returned ObservableSource to emit the latest buffer and complete . If either the source ObservableSource or the boundary ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > compose ( ObservableTransformer < ? super T , ? extends R > composer ) { return wrap ( ( ( ObservableTransformer < T , R > ) ObjectHelper . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6793-L6799<CODESPLIT>Returns an Observable that emits non - overlapping buffered items from the source ObservableSource each time the specified boundary ObservableSource emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer8 . png alt = > <p > Completion of either the source or the boundary ObservableSource causes the returned ObservableSource to emit the latest buffer and complete . If either the source ObservableSource or the boundary ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletableDelayError ( Function < ? super T , ? extends CompletableSource > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5833-L5837<CODESPLIT>Returns an Observable that emits non - overlapping buffered items from the source ObservableSource each time the specified boundary ObservableSource emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer8 . png alt = > <p > Completion of either the source or the boundary ObservableSource causes the returned ObservableSource to emit the latest buffer and complete . If either the source ObservableSource or the boundary ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . COMPUTATION ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , int count ) { return buffer ( timespan , unit , Schedulers . computation ( ) , count ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5181-L5193<CODESPLIT>Returns an Observable that emits non - overlapping buffered items from the source ObservableSource each time the specified boundary ObservableSource emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer8 . png alt = > <p > Completion of either the source or the boundary ObservableSource causes the returned ObservableSource to emit the latest buffer and complete . If either the source ObservableSource or the boundary ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingForEach ( Consumer < ? super T > onNext ) { Iterator < T > it = blockingIterable ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { try { onNext . accept ( it . next ( ) ) ; } catch ( Throwable e ) { Exceptions . throwIfFatal ( e ) ; ( ( Disposable ) it ) . dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( e ) ; } } }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2802-L2807<CODESPLIT>Returns an Observable that emits non - overlapping buffered items from the source ObservableSource each time the specified boundary ObservableSource emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer8 . png alt = > <p > Completion of either the source or the boundary ObservableSource causes the returned ObservableSource to emit the latest buffer and complete . If either the source ObservableSource or the boundary ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > merge ( Iterable < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int bufferSize ) { return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , false , maxConcurrency , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2015-L2022<CODESPLIT>Returns an Observable that emits non - overlapping buffered items from the source ObservableSource each time the specified boundary ObservableSource emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer8 . png alt = > <p > Completion of either the source or the boundary ObservableSource causes the returned ObservableSource to emit the latest buffer and complete . If either the source ObservableSource or the boundary ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ BackpressureSupport ( BackpressureKind . UNBOUNDED_IN ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > fromPublisher ( Publisher < ? extends T > publisher ) { ObjectHelper . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < T > ( publisher ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5409-L5413<CODESPLIT>Returns an Observable that emits non - overlapping buffered items from the source ObservableSource each time the specified boundary ObservableSource emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer8 . png alt = > <p > Completion of either the source or the boundary ObservableSource causes the returned ObservableSource to emit the latest buffer and complete . If either the source ObservableSource or the boundary ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final T blockingSingle ( T defaultItem ) { return single ( defaultItem ) . blockingGet ( ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5603-L5607<CODESPLIT>Returns an Observable that emits non - overlapping buffered items from the source ObservableSource each time the specified boundary ObservableSource emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer8 . png alt = > <p > Completion of either the source or the boundary ObservableSource causes the returned ObservableSource to emit the latest buffer and complete . If either the source ObservableSource or the boundary ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < List < T > > buffer ( int count , int skip ) { return buffer ( count , skip , ArrayListSupplier . < T > asCallable ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6082-L6087<CODESPLIT>Returns an Observable that emits non - overlapping buffered items from the source ObservableSource each time the specified boundary ObservableSource emits an item . <p > <img width = 640 height = 395 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer8 . png alt = > <p > Completion of either the source or the boundary ObservableSource causes the returned ObservableSource to emit the latest buffer and complete . If either the source ObservableSource or the boundary ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < B > Observable < List < T > > buffer ( ObservableSource < B > boundary , final int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return buffer ( boundary , Functions . < T > createArrayList ( initialCapacity ) ) ; }