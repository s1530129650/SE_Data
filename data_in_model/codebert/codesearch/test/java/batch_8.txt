1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>Signals a range of long values the first after some initial delay and the rest periodically after . <p > The sequence completes immediately after the last value ( start + count - 1 ) has been reached . <p > <img width = 640 height = 195 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / intervalRange . s . png alt = > * <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > you provide the {<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > intervalRange ( long start , long count , long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { if ( count < 0 ) { throw new IllegalArgumentException ( "count >= 0 required but it was " + count ) ; } if ( count == 0L ) { return Observable . < Long > empty ( ) . delay ( initialDelay , unit , scheduler ) ; } long end = start + ( count - 1 ) ; if ( start > 0 && end < 0 ) { throw new IllegalArgumentException ( "Overflow! start + count is bigger than Long.MAX_VALUE" ) ; } ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableIntervalRange ( start , end , Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>Signals a range of long values the first after some initial delay and the rest periodically after . <p > The sequence completes immediately after the last value ( start + count - 1 ) has been reached . <p > <img width = 640 height = 195 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / intervalRange . s . png alt = > * <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > you provide the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , int bufferSize ) { return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>Signals a range of long values the first after some initial delay and the rest periodically after . <p > The sequence completes immediately after the last value ( start + count - 1 ) has been reached . <p > <img width = 640 height = 195 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / intervalRange . s . png alt = > * <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > you provide the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMap ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>Signals a range of long values the first after some initial delay and the rest periodically after . <p > The sequence completes immediately after the last value ( start + count - 1 ) has been reached . <p > <img width = 640 height = 195 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / intervalRange . s . png alt = > * <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > you provide the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zipArray ( Function < ? super Object [ ] , ? extends R > zipper , boolean delayError , int bufferSize , ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( sources , null , zipper , bufferSize , delayError ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>Signals a range of long values the first after some initial delay and the rest periodically after . <p > The sequence completes immediately after the last value ( start + count - 1 ) has been reached . <p > <img width = 640 height = 195 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / intervalRange . s . png alt = > * <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > you provide the {<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > switchOnNextDelayError ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int prefetch ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMap ( sources , Functions . identity ( ) , prefetch , true ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>Signals a range of long values the first after some initial delay and the rest periodically after . <p > The sequence completes immediately after the last value ( start + count - 1 ) has been reached . <p > <img width = 640 height = 195 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / intervalRange . s . png alt = > * <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > you provide the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , Callable < U > bufferSupplier ) { return buffer ( count , count , bufferSupplier ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>Signals a range of long values the first after some initial delay and the rest periodically after . <p > The sequence completes immediately after the last value ( start + count - 1 ) has been reached . <p > <img width = 640 height = 195 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / intervalRange . s . png alt = > * <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > you provide the {<CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext ) { ObservableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>Signals a range of long values the first after some initial delay and the rest periodically after . <p > The sequence completes immediately after the last value ( start + count - 1 ) has been reached . <p > <img width = 640 height = 195 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / intervalRange . s . png alt = > * <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > you provide the {<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatEager ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int prefetch ) { return wrap ( sources ) . concatMapEager ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>Signals a range of long values the first after some initial delay and the rest periodically after . <p > The sequence completes immediately after the last value ( start + count - 1 ) has been reached . <p > <img width = 640 height = 195 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / intervalRange . s . png alt = > * <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > you provide the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper , int capacityHint ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( capacityHint , "capacityHint" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , ErrorMode . IMMEDIATE , capacityHint ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>Signals a range of long values the first after some initial delay and the rest periodically after . <p > The sequence completes immediately after the last value ( start + count - 1 ) has been reached . <p > <img width = 640 height = 195 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / intervalRange . s . png alt = > * <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > you provide the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count , Callable < U > bufferSupplier , boolean restartTimerOnMaxSize ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; ObjectHelper . verifyPositive ( count , "count" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timespan , unit , scheduler , bufferSupplier , count , restartTimerOnMaxSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > intervalRange ( long start , long count , long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { if ( count < 0 ) { throw new IllegalArgumentException ( "count >= 0 required but it was " + count ) ; } if ( count == 0L ) { return Observable . < Long > empty ( ) . delay ( initialDelay , unit , scheduler ) ; } long end = start + ( count - 1 ) ; if ( start > 0 && end < 0 ) { throw new IllegalArgumentException ( "Overflow! start + count is bigger than Long.MAX_VALUE" ) ; } ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableIntervalRange ( start , end , Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , int bufferSize ) { return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMap ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zipArray ( Function < ? super Object [ ] , ? extends R > zipper , boolean delayError , int bufferSize , ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( sources , null , zipper , bufferSize , delayError ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > switchOnNextDelayError ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int prefetch ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMap ( sources , Functions . identity ( ) , prefetch , true ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , Callable < U > bufferSupplier ) { return buffer ( count , count , bufferSupplier ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext ) { ObservableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatEager ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int prefetch ) { return wrap ( sources ) . concatMapEager ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper , int capacityHint ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( capacityHint , "capacityHint" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , ErrorMode . IMMEDIATE , capacityHint ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count , Callable < U > bufferSupplier , boolean restartTimerOnMaxSize ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; ObjectHelper . verifyPositive ( count , "count" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timespan , unit , scheduler , bufferSupplier , count , restartTimerOnMaxSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > intervalRange ( long start , long count , long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { if ( count < 0 ) { throw new IllegalArgumentException ( "count >= 0 required but it was " + count ) ; } if ( count == 0L ) { return Observable . < Long > empty ( ) . delay ( initialDelay , unit , scheduler ) ; } long end = start + ( count - 1 ) ; if ( start > 0 && end < 0 ) { throw new IllegalArgumentException ( "Overflow! start + count is bigger than Long.MAX_VALUE" ) ; } ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableIntervalRange ( start , end , Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , int bufferSize ) { return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMap ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zipArray ( Function < ? super Object [ ] , ? extends R > zipper , boolean delayError , int bufferSize , ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( sources , null , zipper , bufferSize , delayError ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > switchOnNextDelayError ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int prefetch ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMap ( sources , Functions . identity ( ) , prefetch , true ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , Callable < U > bufferSupplier ) { return buffer ( count , count , bufferSupplier ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext ) { ObservableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatEager ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int prefetch ) { return wrap ( sources ) . concatMapEager ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper , int capacityHint ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( capacityHint , "capacityHint" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , ErrorMode . IMMEDIATE , capacityHint ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>Returns a new Observable that emits items resulting from applying a function that you supply to each item emitted by the source ObservableSource where that function returns an ObservableSource and then emitting the items that result from concatenating those resulting ObservableSources . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMap . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMap } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count , Callable < U > bufferSupplier , boolean restartTimerOnMaxSize ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; ObjectHelper . verifyPositive ( count , "count" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timespan , unit , scheduler , bufferSupplier , count , restartTimerOnMaxSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an array of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( new ObservableSource [] { range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 ) } ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > intervalRange ( long start , long count , long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { if ( count < 0 ) { throw new IllegalArgumentException ( "count >= 0 required but it was " + count ) ; } if ( count == 0L ) { return Observable . < Long > empty ( ) . delay ( initialDelay , unit , scheduler ) ; } long end = start + ( count - 1 ) ; if ( start > 0 && end < 0 ) { throw new IllegalArgumentException ( "Overflow! start + count is bigger than Long.MAX_VALUE" ) ; } ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableIntervalRange ( start , end , Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an array of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( new ObservableSource [] { range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 ) } ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , int bufferSize ) { return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an array of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( new ObservableSource [] { range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 ) } ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMap ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an array of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( new ObservableSource [] { range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 ) } ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zipArray ( Function < ? super Object [ ] , ? extends R > zipper , boolean delayError , int bufferSize , ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( sources , null , zipper , bufferSize , delayError ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an array of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( new ObservableSource [] { range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 ) } ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > switchOnNextDelayError ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int prefetch ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMap ( sources , Functions . identity ( ) , prefetch , true ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an array of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( new ObservableSource [] { range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 ) } ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , Callable < U > bufferSupplier ) { return buffer ( count , count , bufferSupplier ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an array of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( new ObservableSource [] { range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 ) } ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext ) { ObservableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an array of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( new ObservableSource [] { range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 ) } ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatEager ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int prefetch ) { return wrap ( sources ) . concatMapEager ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an array of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( new ObservableSource [] { range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 ) } ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper , int capacityHint ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( capacityHint , "capacityHint" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , ErrorMode . IMMEDIATE , capacityHint ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an array of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( new ObservableSource [] { range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 ) } ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count , Callable < U > bufferSupplier , boolean restartTimerOnMaxSize ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; ObjectHelper . verifyPositive ( count , "count" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timespan , unit , scheduler , bufferSupplier , count , restartTimerOnMaxSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / switchOnNextDelayError . png alt = > <p > { @code switchOnNext } subscribes to an ObservableSource that emits ObservableSources . Each time it observes one of these emitted ObservableSources the ObservableSource returned by { @code switchOnNext } begins emitting the items emitted by that ObservableSource . When a new ObservableSource is emitted { @code switchOnNext } stops emitting items from the earlier - emitted ObservableSource and begins emitting items from the new one . <p > The resulting ObservableSource completes if both the main ObservableSource and the last inner ObservableSource if any complete . If the main ObservableSource signals an onError the termination of the last inner ObservableSource will emit that error as is or wrapped into a CompositeException along with the other possible errors the former inner ObservableSources signalled . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code switchOnNextDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > intervalRange ( long start , long count , long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { if ( count < 0 ) { throw new IllegalArgumentException ( "count >= 0 required but it was " + count ) ; } if ( count == 0L ) { return Observable . < Long > empty ( ) . delay ( initialDelay , unit , scheduler ) ; } long end = start + ( count - 1 ) ; if ( start > 0 && end < 0 ) { throw new IllegalArgumentException ( "Overflow! start + count is bigger than Long.MAX_VALUE" ) ; } ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableIntervalRange ( start , end , Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / switchOnNextDelayError . png alt = > <p > { @code switchOnNext } subscribes to an ObservableSource that emits ObservableSources . Each time it observes one of these emitted ObservableSources the ObservableSource returned by { @code switchOnNext } begins emitting the items emitted by that ObservableSource . When a new ObservableSource is emitted { @code switchOnNext } stops emitting items from the earlier - emitted ObservableSource and begins emitting items from the new one . <p > The resulting ObservableSource completes if both the main ObservableSource and the last inner ObservableSource if any complete . If the main ObservableSource signals an onError the termination of the last inner ObservableSource will emit that error as is or wrapped into a CompositeException along with the other possible errors the former inner ObservableSources signalled . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code switchOnNextDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , int bufferSize ) { return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / switchOnNextDelayError . png alt = > <p > { @code switchOnNext } subscribes to an ObservableSource that emits ObservableSources . Each time it observes one of these emitted ObservableSources the ObservableSource returned by { @code switchOnNext } begins emitting the items emitted by that ObservableSource . When a new ObservableSource is emitted { @code switchOnNext } stops emitting items from the earlier - emitted ObservableSource and begins emitting items from the new one . <p > The resulting ObservableSource completes if both the main ObservableSource and the last inner ObservableSource if any complete . If the main ObservableSource signals an onError the termination of the last inner ObservableSource will emit that error as is or wrapped into a CompositeException along with the other possible errors the former inner ObservableSources signalled . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code switchOnNextDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMap ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / switchOnNextDelayError . png alt = > <p > { @code switchOnNext } subscribes to an ObservableSource that emits ObservableSources . Each time it observes one of these emitted ObservableSources the ObservableSource returned by { @code switchOnNext } begins emitting the items emitted by that ObservableSource . When a new ObservableSource is emitted { @code switchOnNext } stops emitting items from the earlier - emitted ObservableSource and begins emitting items from the new one . <p > The resulting ObservableSource completes if both the main ObservableSource and the last inner ObservableSource if any complete . If the main ObservableSource signals an onError the termination of the last inner ObservableSource will emit that error as is or wrapped into a CompositeException along with the other possible errors the former inner ObservableSources signalled . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code switchOnNextDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zipArray ( Function < ? super Object [ ] , ? extends R > zipper , boolean delayError , int bufferSize , ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( sources , null , zipper , bufferSize , delayError ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / switchOnNextDelayError . png alt = > <p > { @code switchOnNext } subscribes to an ObservableSource that emits ObservableSources . Each time it observes one of these emitted ObservableSources the ObservableSource returned by { @code switchOnNext } begins emitting the items emitted by that ObservableSource . When a new ObservableSource is emitted { @code switchOnNext } stops emitting items from the earlier - emitted ObservableSource and begins emitting items from the new one . <p > The resulting ObservableSource completes if both the main ObservableSource and the last inner ObservableSource if any complete . If the main ObservableSource signals an onError the termination of the last inner ObservableSource will emit that error as is or wrapped into a CompositeException along with the other possible errors the former inner ObservableSources signalled . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code switchOnNextDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > switchOnNextDelayError ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int prefetch ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMap ( sources , Functions . identity ( ) , prefetch , true ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / switchOnNextDelayError . png alt = > <p > { @code switchOnNext } subscribes to an ObservableSource that emits ObservableSources . Each time it observes one of these emitted ObservableSources the ObservableSource returned by { @code switchOnNext } begins emitting the items emitted by that ObservableSource . When a new ObservableSource is emitted { @code switchOnNext } stops emitting items from the earlier - emitted ObservableSource and begins emitting items from the new one . <p > The resulting ObservableSource completes if both the main ObservableSource and the last inner ObservableSource if any complete . If the main ObservableSource signals an onError the termination of the last inner ObservableSource will emit that error as is or wrapped into a CompositeException along with the other possible errors the former inner ObservableSources signalled . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code switchOnNextDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , Callable < U > bufferSupplier ) { return buffer ( count , count , bufferSupplier ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / switchOnNextDelayError . png alt = > <p > { @code switchOnNext } subscribes to an ObservableSource that emits ObservableSources . Each time it observes one of these emitted ObservableSources the ObservableSource returned by { @code switchOnNext } begins emitting the items emitted by that ObservableSource . When a new ObservableSource is emitted { @code switchOnNext } stops emitting items from the earlier - emitted ObservableSource and begins emitting items from the new one . <p > The resulting ObservableSource completes if both the main ObservableSource and the last inner ObservableSource if any complete . If the main ObservableSource signals an onError the termination of the last inner ObservableSource will emit that error as is or wrapped into a CompositeException along with the other possible errors the former inner ObservableSources signalled . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code switchOnNextDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext ) { ObservableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / switchOnNextDelayError . png alt = > <p > { @code switchOnNext } subscribes to an ObservableSource that emits ObservableSources . Each time it observes one of these emitted ObservableSources the ObservableSource returned by { @code switchOnNext } begins emitting the items emitted by that ObservableSource . When a new ObservableSource is emitted { @code switchOnNext } stops emitting items from the earlier - emitted ObservableSource and begins emitting items from the new one . <p > The resulting ObservableSource completes if both the main ObservableSource and the last inner ObservableSource if any complete . If the main ObservableSource signals an onError the termination of the last inner ObservableSource will emit that error as is or wrapped into a CompositeException along with the other possible errors the former inner ObservableSources signalled . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code switchOnNextDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatEager ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int prefetch ) { return wrap ( sources ) . concatMapEager ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / switchOnNextDelayError . png alt = > <p > { @code switchOnNext } subscribes to an ObservableSource that emits ObservableSources . Each time it observes one of these emitted ObservableSources the ObservableSource returned by { @code switchOnNext } begins emitting the items emitted by that ObservableSource . When a new ObservableSource is emitted { @code switchOnNext } stops emitting items from the earlier - emitted ObservableSource and begins emitting items from the new one . <p > The resulting ObservableSource completes if both the main ObservableSource and the last inner ObservableSource if any complete . If the main ObservableSource signals an onError the termination of the last inner ObservableSource will emit that error as is or wrapped into a CompositeException along with the other possible errors the former inner ObservableSources signalled . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code switchOnNextDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper , int capacityHint ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( capacityHint , "capacityHint" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , ErrorMode . IMMEDIATE , capacityHint ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / switchOnNextDelayError . png alt = > <p > { @code switchOnNext } subscribes to an ObservableSource that emits ObservableSources . Each time it observes one of these emitted ObservableSources the ObservableSource returned by { @code switchOnNext } begins emitting the items emitted by that ObservableSource . When a new ObservableSource is emitted { @code switchOnNext } stops emitting items from the earlier - emitted ObservableSource and begins emitting items from the new one . <p > The resulting ObservableSource completes if both the main ObservableSource and the last inner ObservableSource if any complete . If the main ObservableSource signals an onError the termination of the last inner ObservableSource will emit that error as is or wrapped into a CompositeException along with the other possible errors the former inner ObservableSources signalled . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code switchOnNextDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count , Callable < U > bufferSupplier , boolean restartTimerOnMaxSize ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; ObjectHelper . verifyPositive ( count , "count" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timespan , unit , scheduler , bufferSupplier , count , restartTimerOnMaxSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > intervalRange ( long start , long count , long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { if ( count < 0 ) { throw new IllegalArgumentException ( "count >= 0 required but it was " + count ) ; } if ( count == 0L ) { return Observable . < Long > empty ( ) . delay ( initialDelay , unit , scheduler ) ; } long end = start + ( count - 1 ) ; if ( start > 0 && end < 0 ) { throw new IllegalArgumentException ( "Overflow! start + count is bigger than Long.MAX_VALUE" ) ; } ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableIntervalRange ( start , end , Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , int bufferSize ) { return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMap ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zipArray ( Function < ? super Object [ ] , ? extends R > zipper , boolean delayError , int bufferSize , ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( sources , null , zipper , bufferSize , delayError ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > switchOnNextDelayError ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int prefetch ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMap ( sources , Functions . identity ( ) , prefetch , true ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , Callable < U > bufferSupplier ) { return buffer ( count , count , bufferSupplier ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext ) { ObservableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatEager ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int prefetch ) { return wrap ( sources ) . concatMapEager ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper , int capacityHint ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( capacityHint , "capacityHint" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , ErrorMode . IMMEDIATE , capacityHint ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer3 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count , Callable < U > bufferSupplier , boolean restartTimerOnMaxSize ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; ObjectHelper . verifyPositive ( count , "count" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timespan , unit , scheduler , bufferSupplier , count , restartTimerOnMaxSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 393 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . 1 . png alt = > <p > If the {<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > intervalRange ( long start , long count , long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { if ( count < 0 ) { throw new IllegalArgumentException ( "count >= 0 required but it was " + count ) ; } if ( count == 0L ) { return Observable . < Long > empty ( ) . delay ( initialDelay , unit , scheduler ) ; } long end = start + ( count - 1 ) ; if ( start > 0 && end < 0 ) { throw new IllegalArgumentException ( "Overflow! start + count is bigger than Long.MAX_VALUE" ) ; } ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableIntervalRange ( start , end , Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 393 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . 1 . png alt = > <p > If the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , int bufferSize ) { return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 393 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . 1 . png alt = > <p > If the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMap ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 393 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . 1 . png alt = > <p > If the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zipArray ( Function < ? super Object [ ] , ? extends R > zipper , boolean delayError , int bufferSize , ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( sources , null , zipper , bufferSize , delayError ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 393 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . 1 . png alt = > <p > If the {<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > switchOnNextDelayError ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int prefetch ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMap ( sources , Functions . identity ( ) , prefetch , true ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 393 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . 1 . png alt = > <p > If the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , Callable < U > bufferSupplier ) { return buffer ( count , count , bufferSupplier ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 393 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . 1 . png alt = > <p > If the {<CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext ) { ObservableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 393 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . 1 . png alt = > <p > If the {<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatEager ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int prefetch ) { return wrap ( sources ) . concatMapEager ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 393 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . 1 . png alt = > <p > If the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper , int capacityHint ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( capacityHint , "capacityHint" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , ErrorMode . IMMEDIATE , capacityHint ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>Subscribes to the source and calls the given callbacks <strong > on the current thread< / strong > . <p > <img width = 640 height = 393 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / blockingSubscribe . o . 1 . png alt = > <p > If the {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count , Callable < U > bufferSupplier , boolean restartTimerOnMaxSize ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; ObjectHelper . verifyPositive ( count , "count" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timespan , unit , scheduler , bufferSupplier , count , restartTimerOnMaxSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>Concatenates an ObservableSource sequence of ObservableSources eagerly into a single stream of values . <p > Eager concatenation means that once a subscriber subscribes this operator subscribes to all of the emitted source ObservableSources as they are observed . The operator buffers the values emitted by these ObservableSources and then drains them in order each one after the previous one completes . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatEager . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This method does not operate by default on a particular {<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > intervalRange ( long start , long count , long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { if ( count < 0 ) { throw new IllegalArgumentException ( "count >= 0 required but it was " + count ) ; } if ( count == 0L ) { return Observable . < Long > empty ( ) . delay ( initialDelay , unit , scheduler ) ; } long end = start + ( count - 1 ) ; if ( start > 0 && end < 0 ) { throw new IllegalArgumentException ( "Overflow! start + count is bigger than Long.MAX_VALUE" ) ; } ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableIntervalRange ( start , end , Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>Concatenates an ObservableSource sequence of ObservableSources eagerly into a single stream of values . <p > Eager concatenation means that once a subscriber subscribes this operator subscribes to all of the emitted source ObservableSources as they are observed . The operator buffers the values emitted by these ObservableSources and then drains them in order each one after the previous one completes . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatEager . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This method does not operate by default on a particular {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , int bufferSize ) { return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>Concatenates an ObservableSource sequence of ObservableSources eagerly into a single stream of values . <p > Eager concatenation means that once a subscriber subscribes this operator subscribes to all of the emitted source ObservableSources as they are observed . The operator buffers the values emitted by these ObservableSources and then drains them in order each one after the previous one completes . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatEager . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This method does not operate by default on a particular {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMap ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>Concatenates an ObservableSource sequence of ObservableSources eagerly into a single stream of values . <p > Eager concatenation means that once a subscriber subscribes this operator subscribes to all of the emitted source ObservableSources as they are observed . The operator buffers the values emitted by these ObservableSources and then drains them in order each one after the previous one completes . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatEager . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This method does not operate by default on a particular {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zipArray ( Function < ? super Object [ ] , ? extends R > zipper , boolean delayError , int bufferSize , ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( sources , null , zipper , bufferSize , delayError ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>Concatenates an ObservableSource sequence of ObservableSources eagerly into a single stream of values . <p > Eager concatenation means that once a subscriber subscribes this operator subscribes to all of the emitted source ObservableSources as they are observed . The operator buffers the values emitted by these ObservableSources and then drains them in order each one after the previous one completes . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatEager . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This method does not operate by default on a particular {<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > switchOnNextDelayError ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int prefetch ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMap ( sources , Functions . identity ( ) , prefetch , true ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>Concatenates an ObservableSource sequence of ObservableSources eagerly into a single stream of values . <p > Eager concatenation means that once a subscriber subscribes this operator subscribes to all of the emitted source ObservableSources as they are observed . The operator buffers the values emitted by these ObservableSources and then drains them in order each one after the previous one completes . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatEager . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This method does not operate by default on a particular {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , Callable < U > bufferSupplier ) { return buffer ( count , count , bufferSupplier ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>Concatenates an ObservableSource sequence of ObservableSources eagerly into a single stream of values . <p > Eager concatenation means that once a subscriber subscribes this operator subscribes to all of the emitted source ObservableSources as they are observed . The operator buffers the values emitted by these ObservableSources and then drains them in order each one after the previous one completes . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatEager . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This method does not operate by default on a particular {<CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext ) { ObservableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>Concatenates an ObservableSource sequence of ObservableSources eagerly into a single stream of values . <p > Eager concatenation means that once a subscriber subscribes this operator subscribes to all of the emitted source ObservableSources as they are observed . The operator buffers the values emitted by these ObservableSources and then drains them in order each one after the previous one completes . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatEager . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This method does not operate by default on a particular {<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatEager ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int prefetch ) { return wrap ( sources ) . concatMapEager ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>Concatenates an ObservableSource sequence of ObservableSources eagerly into a single stream of values . <p > Eager concatenation means that once a subscriber subscribes this operator subscribes to all of the emitted source ObservableSources as they are observed . The operator buffers the values emitted by these ObservableSources and then drains them in order each one after the previous one completes . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatEager . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This method does not operate by default on a particular {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper , int capacityHint ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( capacityHint , "capacityHint" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , ErrorMode . IMMEDIATE , capacityHint ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>Concatenates an ObservableSource sequence of ObservableSources eagerly into a single stream of values . <p > Eager concatenation means that once a subscriber subscribes this operator subscribes to all of the emitted source ObservableSources as they are observed . The operator buffers the values emitted by these ObservableSources and then drains them in order each one after the previous one completes . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatEager . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This method does not operate by default on a particular {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count , Callable < U > bufferSupplier , boolean restartTimerOnMaxSize ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; ObjectHelper . verifyPositive ( count , "count" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timespan , unit , scheduler , bufferSupplier , count , restartTimerOnMaxSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapCompletable } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl > <p > History : 2 . 1 . 6 - experimental @param mapper a function that when applied to an item emitted by the source ObservableSource returns a CompletableSource<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > intervalRange ( long start , long count , long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { if ( count < 0 ) { throw new IllegalArgumentException ( "count >= 0 required but it was " + count ) ; } if ( count == 0L ) { return Observable . < Long > empty ( ) . delay ( initialDelay , unit , scheduler ) ; } long end = start + ( count - 1 ) ; if ( start > 0 && end < 0 ) { throw new IllegalArgumentException ( "Overflow! start + count is bigger than Long.MAX_VALUE" ) ; } ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableIntervalRange ( start , end , Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapCompletable } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl > <p > History : 2 . 1 . 6 - experimental @param mapper a function that when applied to an item emitted by the source ObservableSource returns a CompletableSource<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , int bufferSize ) { return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapCompletable } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl > <p > History : 2 . 1 . 6 - experimental @param mapper a function that when applied to an item emitted by the source ObservableSource returns a CompletableSource<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMap ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapCompletable } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl > <p > History : 2 . 1 . 6 - experimental @param mapper a function that when applied to an item emitted by the source ObservableSource returns a CompletableSource<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zipArray ( Function < ? super Object [ ] , ? extends R > zipper , boolean delayError , int bufferSize , ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( sources , null , zipper , bufferSize , delayError ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapCompletable } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl > <p > History : 2 . 1 . 6 - experimental @param mapper a function that when applied to an item emitted by the source ObservableSource returns a CompletableSource<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > switchOnNextDelayError ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int prefetch ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMap ( sources , Functions . identity ( ) , prefetch , true ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapCompletable } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl > <p > History : 2 . 1 . 6 - experimental @param mapper a function that when applied to an item emitted by the source ObservableSource returns a CompletableSource<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , Callable < U > bufferSupplier ) { return buffer ( count , count , bufferSupplier ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapCompletable } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl > <p > History : 2 . 1 . 6 - experimental @param mapper a function that when applied to an item emitted by the source ObservableSource returns a CompletableSource<CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext ) { ObservableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapCompletable } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl > <p > History : 2 . 1 . 6 - experimental @param mapper a function that when applied to an item emitted by the source ObservableSource returns a CompletableSource<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatEager ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int prefetch ) { return wrap ( sources ) . concatMapEager ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapCompletable } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl > <p > History : 2 . 1 . 6 - experimental @param mapper a function that when applied to an item emitted by the source ObservableSource returns a CompletableSource<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper , int capacityHint ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( capacityHint , "capacityHint" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , ErrorMode . IMMEDIATE , capacityHint ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapCompletable } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl > <p > History : 2 . 1 . 6 - experimental @param mapper a function that when applied to an item emitted by the source ObservableSource returns a CompletableSource<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count , Callable < U > bufferSupplier , boolean restartTimerOnMaxSize ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; ObjectHelper . verifyPositive ( count , "count" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timespan , unit , scheduler , bufferSupplier , count , restartTimerOnMaxSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2335-L2355<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > intervalRange ( long start , long count , long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { if ( count < 0 ) { throw new IllegalArgumentException ( "count >= 0 required but it was " + count ) ; } if ( count == 0L ) { return Observable . < Long > empty ( ) . delay ( initialDelay , unit , scheduler ) ; } long end = start + ( count - 1 ) ; if ( start > 0 && end < 0 ) { throw new IllegalArgumentException ( "Overflow! start + count is bigger than Long.MAX_VALUE" ) ; } ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableIntervalRange ( start , end , Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3784-L3789<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , int bufferSize ) { return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6439-L6443<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMap ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMap ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4927-L4937<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zipArray ( Function < ? super Object [ ] , ? extends R > zipper , boolean delayError , int bufferSize , ObservableSource < ? extends T > ... sources ) { if ( sources . length == 0 ) { return empty ( ) ; } ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( sources , null , zipper , bufferSize , delayError ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3920-L3927<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > switchOnNextDelayError ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int prefetch ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMap ( sources , Functions . identity ( ) , prefetch , true ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5668-L5672<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , Callable < U > bufferSupplier ) { return buffer ( count , count , bufferSupplier ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5485-L5488<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ SchedulerSupport ( SchedulerSupport . NONE ) public final void blockingSubscribe ( Consumer < ? super T > onNext ) { ObservableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1529-L1534<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatEager ( ObservableSource < ? extends ObservableSource < ? extends T > > sources , int maxConcurrency , int prefetch ) { return wrap ( sources ) . concatMapEager ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6703-L6709<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper , int capacityHint ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( capacityHint , "capacityHint" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapCompletable < T > ( this , mapper , ErrorMode . IMMEDIATE , capacityHint ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5909-L5921<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count , Callable < U > bufferSupplier , boolean restartTimerOnMaxSize ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; ObjectHelper . verifyPositive ( count , "count" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timespan , unit , scheduler , bufferSupplier , count , restartTimerOnMaxSize ) ) ; }