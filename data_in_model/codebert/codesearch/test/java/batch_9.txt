1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper ) { return concatMapCompletable ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , BiPredicate < ? super T , ? super T > isEqual , int bufferSize ) { ObjectHelper . requireNonNull ( source1 , "source1 is null" ) ; ObjectHelper . requireNonNull ( source2 , "source2 is null" ) ; ObjectHelper . requireNonNull ( isEqual , "isEqual is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableSequenceEqualSingle < T > ( source1 , source2 , isEqual , bufferSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > interval ( long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableInterval ( Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapDelayError ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMapDelayError ( mapper , bufferSize ( ) , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayEagerDelayError ( int maxConcurrency , int prefetch , ObservableSource < ? extends T > ... sources ) { return fromArray ( sources ) . concatMapEagerDelayError ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybeDelayError ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , long timeskip , TimeUnit unit , Scheduler scheduler , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timeskip , unit , scheduler , bufferSupplier , Integer . MAX_VALUE , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , int skip , Callable < U > bufferSupplier ) { ObjectHelper . verifyPositive ( count , "count" ) ; ObjectHelper . verifyPositive ( skip , "skip" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBuffer < T , U > ( this , count , skip , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > all ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAllSingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>Maps each element of the upstream Observable into CompletableSources subscribes to them one at a time in order and waits until the upstream and all CompletableSources complete . <p > <img width = 640 height = 505 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapCompletable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( Iterable < ? extends ObservableSource < ? extends T > > sources , Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( null , sources , zipper , bufferSize ( ) , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise based on the results of a specified equality function . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper ) { return concatMapCompletable ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise based on the results of a specified equality function . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , BiPredicate < ? super T , ? super T > isEqual , int bufferSize ) { ObjectHelper . requireNonNull ( source1 , "source1 is null" ) ; ObjectHelper . requireNonNull ( source2 , "source2 is null" ) ; ObjectHelper . requireNonNull ( isEqual , "isEqual is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableSequenceEqualSingle < T > ( source1 , source2 , isEqual , bufferSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise based on the results of a specified equality function . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > interval ( long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableInterval ( Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise based on the results of a specified equality function . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapDelayError ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMapDelayError ( mapper , bufferSize ( ) , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise based on the results of a specified equality function . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayEagerDelayError ( int maxConcurrency , int prefetch , ObservableSource < ? extends T > ... sources ) { return fromArray ( sources ) . concatMapEagerDelayError ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise based on the results of a specified equality function . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybeDelayError ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise based on the results of a specified equality function . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , long timeskip , TimeUnit unit , Scheduler scheduler , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timeskip , unit , scheduler , bufferSupplier , Integer . MAX_VALUE , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise based on the results of a specified equality function . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , int skip , Callable < U > bufferSupplier ) { ObjectHelper . verifyPositive ( count , "count" ) ; ObjectHelper . verifyPositive ( skip , "skip" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBuffer < T , U > ( this , count , skip , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise based on the results of a specified equality function . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > all ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAllSingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the same by comparing the items emitted by each ObservableSource pairwise based on the results of a specified equality function . <p > <img width = 640 height = 380 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sequenceEqual . 2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code sequenceEqual } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( Iterable < ? extends ObservableSource < ? extends T > > sources , Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( null , sources , zipper , bufferSize ( ) , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>Returns an Observable that emits a { @code 0L } after the { @code initialDelay } and ever increasing numbers after each { @code period } of time thereafter on a specified { @link Scheduler } . <p > <img width = 640 height = 200 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / timer . ps . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper ) { return concatMapCompletable ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>Returns an Observable that emits a { @code 0L } after the { @code initialDelay } and ever increasing numbers after each { @code period } of time thereafter on a specified { @link Scheduler } . <p > <img width = 640 height = 200 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / timer . ps . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , BiPredicate < ? super T , ? super T > isEqual , int bufferSize ) { ObjectHelper . requireNonNull ( source1 , "source1 is null" ) ; ObjectHelper . requireNonNull ( source2 , "source2 is null" ) ; ObjectHelper . requireNonNull ( isEqual , "isEqual is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableSequenceEqualSingle < T > ( source1 , source2 , isEqual , bufferSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>Returns an Observable that emits a { @code 0L } after the { @code initialDelay } and ever increasing numbers after each { @code period } of time thereafter on a specified { @link Scheduler } . <p > <img width = 640 height = 200 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / timer . ps . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > interval ( long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableInterval ( Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>Returns an Observable that emits a { @code 0L } after the { @code initialDelay } and ever increasing numbers after each { @code period } of time thereafter on a specified { @link Scheduler } . <p > <img width = 640 height = 200 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / timer . ps . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapDelayError ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMapDelayError ( mapper , bufferSize ( ) , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>Returns an Observable that emits a { @code 0L } after the { @code initialDelay } and ever increasing numbers after each { @code period } of time thereafter on a specified { @link Scheduler } . <p > <img width = 640 height = 200 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / timer . ps . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayEagerDelayError ( int maxConcurrency , int prefetch , ObservableSource < ? extends T > ... sources ) { return fromArray ( sources ) . concatMapEagerDelayError ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>Returns an Observable that emits a { @code 0L } after the { @code initialDelay } and ever increasing numbers after each { @code period } of time thereafter on a specified { @link Scheduler } . <p > <img width = 640 height = 200 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / timer . ps . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybeDelayError ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>Returns an Observable that emits a { @code 0L } after the { @code initialDelay } and ever increasing numbers after each { @code period } of time thereafter on a specified { @link Scheduler } . <p > <img width = 640 height = 200 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / timer . ps . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , long timeskip , TimeUnit unit , Scheduler scheduler , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timeskip , unit , scheduler , bufferSupplier , Integer . MAX_VALUE , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>Returns an Observable that emits a { @code 0L } after the { @code initialDelay } and ever increasing numbers after each { @code period } of time thereafter on a specified { @link Scheduler } . <p > <img width = 640 height = 200 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / timer . ps . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , int skip , Callable < U > bufferSupplier ) { ObjectHelper . verifyPositive ( count , "count" ) ; ObjectHelper . verifyPositive ( skip , "skip" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBuffer < T , U > ( this , count , skip , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>Returns an Observable that emits a { @code 0L } after the { @code initialDelay } and ever increasing numbers after each { @code period } of time thereafter on a specified { @link Scheduler } . <p > <img width = 640 height = 200 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / timer . ps . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > all ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAllSingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>Returns an Observable that emits a { @code 0L } after the { @code initialDelay } and ever increasing numbers after each { @code period } of time thereafter on a specified { @link Scheduler } . <p > <img width = 640 height = 200 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / timer . ps . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( Iterable < ? extends ObservableSource < ? extends T > > sources , Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( null , sources , zipper , bufferSize ( ) , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>Maps each of the items into an ObservableSource subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner ObservableSources till all of them terminate . <p > <img width = 640 height = 347 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapDelayError . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper ) { return concatMapCompletable ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>Maps each of the items into an ObservableSource subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner ObservableSources till all of them terminate . <p > <img width = 640 height = 347 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapDelayError . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , BiPredicate < ? super T , ? super T > isEqual , int bufferSize ) { ObjectHelper . requireNonNull ( source1 , "source1 is null" ) ; ObjectHelper . requireNonNull ( source2 , "source2 is null" ) ; ObjectHelper . requireNonNull ( isEqual , "isEqual is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableSequenceEqualSingle < T > ( source1 , source2 , isEqual , bufferSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>Maps each of the items into an ObservableSource subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner ObservableSources till all of them terminate . <p > <img width = 640 height = 347 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapDelayError . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > interval ( long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableInterval ( Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>Maps each of the items into an ObservableSource subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner ObservableSources till all of them terminate . <p > <img width = 640 height = 347 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapDelayError . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapDelayError ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMapDelayError ( mapper , bufferSize ( ) , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>Maps each of the items into an ObservableSource subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner ObservableSources till all of them terminate . <p > <img width = 640 height = 347 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapDelayError . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayEagerDelayError ( int maxConcurrency , int prefetch , ObservableSource < ? extends T > ... sources ) { return fromArray ( sources ) . concatMapEagerDelayError ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>Maps each of the items into an ObservableSource subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner ObservableSources till all of them terminate . <p > <img width = 640 height = 347 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapDelayError . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybeDelayError ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>Maps each of the items into an ObservableSource subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner ObservableSources till all of them terminate . <p > <img width = 640 height = 347 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapDelayError . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , long timeskip , TimeUnit unit , Scheduler scheduler , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timeskip , unit , scheduler , bufferSupplier , Integer . MAX_VALUE , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>Maps each of the items into an ObservableSource subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner ObservableSources till all of them terminate . <p > <img width = 640 height = 347 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapDelayError . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , int skip , Callable < U > bufferSupplier ) { ObjectHelper . verifyPositive ( count , "count" ) ; ObjectHelper . verifyPositive ( skip , "skip" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBuffer < T , U > ( this , count , skip , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>Maps each of the items into an ObservableSource subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner ObservableSources till all of them terminate . <p > <img width = 640 height = 347 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapDelayError . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > all ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAllSingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>Maps each of the items into an ObservableSource subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner ObservableSources till all of them terminate . <p > <img width = 640 height = 347 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / concatMapDelayError . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code concatMapDelayError } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( Iterable < ? extends ObservableSource < ? extends T > > sources , Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( null , sources , zipper , bufferSize ( ) , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>Concatenates an array of {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper ) { return concatMapCompletable ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>Concatenates an array of {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , BiPredicate < ? super T , ? super T > isEqual , int bufferSize ) { ObjectHelper . requireNonNull ( source1 , "source1 is null" ) ; ObjectHelper . requireNonNull ( source2 , "source2 is null" ) ; ObjectHelper . requireNonNull ( isEqual , "isEqual is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableSequenceEqualSingle < T > ( source1 , source2 , isEqual , bufferSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>Concatenates an array of {<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > interval ( long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableInterval ( Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>Concatenates an array of {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapDelayError ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMapDelayError ( mapper , bufferSize ( ) , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>Concatenates an array of {<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayEagerDelayError ( int maxConcurrency , int prefetch , ObservableSource < ? extends T > ... sources ) { return fromArray ( sources ) . concatMapEagerDelayError ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>Concatenates an array of {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybeDelayError ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>Concatenates an array of {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , long timeskip , TimeUnit unit , Scheduler scheduler , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timeskip , unit , scheduler , bufferSupplier , Integer . MAX_VALUE , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>Concatenates an array of {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , int skip , Callable < U > bufferSupplier ) { ObjectHelper . verifyPositive ( count , "count" ) ; ObjectHelper . verifyPositive ( skip , "skip" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBuffer < T , U > ( this , count , skip , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>Concatenates an array of {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > all ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAllSingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>Concatenates an array of {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( Iterable < ? extends ObservableSource < ? extends T > > sources , Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( null , sources , zipper , bufferSize ( ) , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper ) { return concatMapCompletable ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , BiPredicate < ? super T , ? super T > isEqual , int bufferSize ) { ObjectHelper . requireNonNull ( source1 , "source1 is null" ) ; ObjectHelper . requireNonNull ( source2 , "source2 is null" ) ; ObjectHelper . requireNonNull ( isEqual , "isEqual is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableSequenceEqualSingle < T > ( source1 , source2 , isEqual , bufferSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > interval ( long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableInterval ( Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapDelayError ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMapDelayError ( mapper , bufferSize ( ) , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayEagerDelayError ( int maxConcurrency , int prefetch , ObservableSource < ? extends T > ... sources ) { return fromArray ( sources ) . concatMapEagerDelayError ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybeDelayError ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , long timeskip , TimeUnit unit , Scheduler scheduler , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timeskip , unit , scheduler , bufferSupplier , Integer . MAX_VALUE , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , int skip , Callable < U > bufferSupplier ) { ObjectHelper . verifyPositive ( count , "count" ) ; ObjectHelper . verifyPositive ( skip , "skip" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBuffer < T , U > ( this , count , skip , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > all ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAllSingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( Iterable < ? extends ObservableSource < ? extends T > > sources , Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( null , sources , zipper , bufferSize ( ) , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource starts a new buffer periodically as determined by the { @code timeskip } argument and on the specified { @code scheduler } . It emits each buffer after a fixed timespan specified by the { @code timespan } argument . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer7 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper ) { return concatMapCompletable ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource starts a new buffer periodically as determined by the { @code timeskip } argument and on the specified { @code scheduler } . It emits each buffer after a fixed timespan specified by the { @code timespan } argument . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer7 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , BiPredicate < ? super T , ? super T > isEqual , int bufferSize ) { ObjectHelper . requireNonNull ( source1 , "source1 is null" ) ; ObjectHelper . requireNonNull ( source2 , "source2 is null" ) ; ObjectHelper . requireNonNull ( isEqual , "isEqual is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableSequenceEqualSingle < T > ( source1 , source2 , isEqual , bufferSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource starts a new buffer periodically as determined by the { @code timeskip } argument and on the specified { @code scheduler } . It emits each buffer after a fixed timespan specified by the { @code timespan } argument . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer7 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > interval ( long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableInterval ( Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource starts a new buffer periodically as determined by the { @code timeskip } argument and on the specified { @code scheduler } . It emits each buffer after a fixed timespan specified by the { @code timespan } argument . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer7 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapDelayError ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMapDelayError ( mapper , bufferSize ( ) , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource starts a new buffer periodically as determined by the { @code timeskip } argument and on the specified { @code scheduler } . It emits each buffer after a fixed timespan specified by the { @code timespan } argument . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer7 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayEagerDelayError ( int maxConcurrency , int prefetch , ObservableSource < ? extends T > ... sources ) { return fromArray ( sources ) . concatMapEagerDelayError ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource starts a new buffer periodically as determined by the { @code timeskip } argument and on the specified { @code scheduler } . It emits each buffer after a fixed timespan specified by the { @code timespan } argument . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer7 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybeDelayError ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource starts a new buffer periodically as determined by the { @code timeskip } argument and on the specified { @code scheduler } . It emits each buffer after a fixed timespan specified by the { @code timespan } argument . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer7 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , long timeskip , TimeUnit unit , Scheduler scheduler , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timeskip , unit , scheduler , bufferSupplier , Integer . MAX_VALUE , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource starts a new buffer periodically as determined by the { @code timeskip } argument and on the specified { @code scheduler } . It emits each buffer after a fixed timespan specified by the { @code timespan } argument . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer7 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , int skip , Callable < U > bufferSupplier ) { ObjectHelper . verifyPositive ( count , "count" ) ; ObjectHelper . verifyPositive ( skip , "skip" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBuffer < T , U > ( this , count , skip , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource starts a new buffer periodically as determined by the { @code timeskip } argument and on the specified { @code scheduler } . It emits each buffer after a fixed timespan specified by the { @code timespan } argument . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer7 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > all ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAllSingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource starts a new buffer periodically as determined by the { @code timeskip } argument and on the specified { @code scheduler } . It emits each buffer after a fixed timespan specified by the { @code timespan } argument . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer7 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( Iterable < ? extends ObservableSource < ? extends T > > sources , Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( null , sources , zipper , bufferSize ( ) , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper ) { return concatMapCompletable ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , BiPredicate < ? super T , ? super T > isEqual , int bufferSize ) { ObjectHelper . requireNonNull ( source1 , "source1 is null" ) ; ObjectHelper . requireNonNull ( source2 , "source2 is null" ) ; ObjectHelper . requireNonNull ( isEqual , "isEqual is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableSequenceEqualSingle < T > ( source1 , source2 , isEqual , bufferSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > interval ( long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableInterval ( Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapDelayError ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMapDelayError ( mapper , bufferSize ( ) , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayEagerDelayError ( int maxConcurrency , int prefetch , ObservableSource < ? extends T > ... sources ) { return fromArray ( sources ) . concatMapEagerDelayError ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybeDelayError ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , long timeskip , TimeUnit unit , Scheduler scheduler , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timeskip , unit , scheduler , bufferSupplier , Integer . MAX_VALUE , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , int skip , Callable < U > bufferSupplier ) { ObjectHelper . verifyPositive ( count , "count" ) ; ObjectHelper . verifyPositive ( skip , "skip" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBuffer < T , U > ( this , count , skip , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > all ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAllSingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers every { @code skip } items each containing { @code count } items . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer4 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( Iterable < ? extends ObservableSource < ? extends T > > sources , Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( null , sources , zipper , bufferSize ( ) , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source ObservableSource satisfy a condition . <p > <img width = 640 height = 264 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / all . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code all } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper ) { return concatMapCompletable ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source ObservableSource satisfy a condition . <p > <img width = 640 height = 264 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / all . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code all } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , BiPredicate < ? super T , ? super T > isEqual , int bufferSize ) { ObjectHelper . requireNonNull ( source1 , "source1 is null" ) ; ObjectHelper . requireNonNull ( source2 , "source2 is null" ) ; ObjectHelper . requireNonNull ( isEqual , "isEqual is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableSequenceEqualSingle < T > ( source1 , source2 , isEqual , bufferSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source ObservableSource satisfy a condition . <p > <img width = 640 height = 264 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / all . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code all } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > interval ( long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableInterval ( Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source ObservableSource satisfy a condition . <p > <img width = 640 height = 264 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / all . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code all } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapDelayError ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMapDelayError ( mapper , bufferSize ( ) , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source ObservableSource satisfy a condition . <p > <img width = 640 height = 264 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / all . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code all } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayEagerDelayError ( int maxConcurrency , int prefetch , ObservableSource < ? extends T > ... sources ) { return fromArray ( sources ) . concatMapEagerDelayError ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source ObservableSource satisfy a condition . <p > <img width = 640 height = 264 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / all . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code all } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybeDelayError ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source ObservableSource satisfy a condition . <p > <img width = 640 height = 264 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / all . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code all } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , long timeskip , TimeUnit unit , Scheduler scheduler , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timeskip , unit , scheduler , bufferSupplier , Integer . MAX_VALUE , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source ObservableSource satisfy a condition . <p > <img width = 640 height = 264 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / all . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code all } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , int skip , Callable < U > bufferSupplier ) { ObjectHelper . verifyPositive ( count , "count" ) ; ObjectHelper . verifyPositive ( skip , "skip" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBuffer < T , U > ( this , count , skip , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source ObservableSource satisfy a condition . <p > <img width = 640 height = 264 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / all . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code all } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > all ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAllSingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source ObservableSource satisfy a condition . <p > <img width = 640 height = 264 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / all . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code all } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( Iterable < ? extends ObservableSource < ? extends T > > sources , Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( null , sources , zipper , bufferSize ( ) , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6678-L6682<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an Iterable of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( Arrays . asList ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Completable concatMapCompletable ( Function < ? super T , ? extends CompletableSource > mapper ) { return concatMapCompletable ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L3752-L3761<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an Iterable of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( Arrays . asList ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < Boolean > sequenceEqual ( ObservableSource < ? extends T > source1 , ObservableSource < ? extends T > source2 , BiPredicate < ? super T , ? super T > isEqual , int bufferSize ) { ObjectHelper . requireNonNull ( source1 , "source1 is null" ) ; ObjectHelper . requireNonNull ( source2 , "source2 is null" ) ; ObjectHelper . requireNonNull ( isEqual , "isEqual is null" ) ; ObjectHelper . verifyPositive ( bufferSize , "bufferSize" ) ; return RxJavaPlugins . onAssembly ( new ObservableSequenceEqualSingle < T > ( source1 , source2 , isEqual , bufferSize ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2238-L2246<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an Iterable of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( Arrays . asList ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > interval ( long initialDelay , long period , TimeUnit unit , Scheduler scheduler ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableInterval ( Math . max ( 0L , initialDelay ) , Math . max ( 0L , period ) , unit , scheduler ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6498-L6502<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an Iterable of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( Arrays . asList ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapDelayError ( Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { return concatMapDelayError ( mapper , bufferSize ( ) , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L1410-L1415<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an Iterable of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( Arrays . asList ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > concatArrayEagerDelayError ( int maxConcurrency , int prefetch , ObservableSource < ? extends T > ... sources ) { return fromArray ( sources ) . concatMapEagerDelayError ( ( Function ) Functions . identity ( ) , maxConcurrency , prefetch , true ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7003-L7009<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an Iterable of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( Arrays . asList ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybeDelayError ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5768-L5775<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an Iterable of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( Arrays . asList ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final < U extends Collection < ? super T > > Observable < U > buffer ( long timespan , long timeskip , TimeUnit unit , Scheduler scheduler , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( unit , "unit is null" ) ; ObjectHelper . requireNonNull ( scheduler , "scheduler is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferTimed < T , U > ( this , timespan , timeskip , unit , scheduler , bufferSupplier , Integer . MAX_VALUE , false ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5636-L5643<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an Iterable of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( Arrays . asList ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U extends Collection < ? super T > > Observable < U > buffer ( int count , int skip , Callable < U > bufferSupplier ) { ObjectHelper . verifyPositive ( count , "count" ) ; ObjectHelper . verifyPositive ( skip , "skip" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBuffer < T , U > ( this , count , skip , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5020-L5025<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an Iterable of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( Arrays . asList ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > all ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAllSingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4137-L4143<CODESPLIT>Returns an Observable that emits the results of a specified combiner function applied to combinations of items emitted in sequence by an Iterable of other ObservableSources . <p > { @code zip } applies this function in strict sequence so the first item emitted by the new ObservableSource will be the result of the function applied to the first item emitted by each of the source ObservableSources ; the second item emitted by the new ObservableSource will be the result of the function applied to the second item emitted by each of those ObservableSources ; and so forth . <p > The resulting { @code ObservableSource<R > } returned from { @code zip } will invoke { @code onNext } as many times as the number of { @code onNext } invocations of the source ObservableSource that emits the fewest items . <p > The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources . Therefore it is possible those other sources will never be able to run to completion ( and thus not calling { @code doOnComplete () } ) . This can also happen if the sources are exactly the same length ; if source A completes and B has been consumed and is about to complete the operator detects A won t be sending further values and it will dispose B immediately . For example : <pre > <code > zip ( Arrays . asList ( range ( 1 5 ) . doOnComplete ( action1 ) range ( 6 5 ) . doOnComplete ( action2 )) ( a ) - &gt ; a ) < / code > < / pre > { @code action1 } will be called but { @code action2 } won t . <br > To work around this termination property use { @link #doOnDispose ( Action ) } as well or use { @code using () } to do cleanup in case of completion or a dispose () call . <p > Note on method signature : since Java doesn t allow creating a generic array with { @code new T [] } the implementation of this operator has to create an { @code Object [] } instead . Unfortunately a { @code Function<Integer [] R > } passed to the method would trigger a { @code ClassCastException } .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , R > Observable < R > zip ( Iterable < ? extends ObservableSource < ? extends T > > sources , Function < ? super Object [ ] , ? extends R > zipper ) { ObjectHelper . requireNonNull ( zipper , "zipper is null" ) ; ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < T , R > ( null , sources , zipper , bufferSize ( ) , false ) ) ; }