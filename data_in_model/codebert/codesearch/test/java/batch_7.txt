1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>Returns a cold synchronous and stateless generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > generate ( final Consumer < Emitter < T > > generator ) { ObjectHelper . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . < Object > nullSupplier ( ) , ObservableInternalHelper . simpleGenerator ( generator ) , Functions . < Object > emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>Returns a cold synchronous and stateless generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static < T > Observable < T > merge ( ObservableSource < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE , bufferSize ( ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>Returns a cold synchronous and stateless generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > any ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAnySingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>Returns a cold synchronous and stateless generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper ) { return concatMapSingle ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>Returns a cold synchronous and stateless generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>Returns a cold synchronous and stateless generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count ) { return buffer ( timespan , unit , scheduler , count , ArrayListSupplier . < T > asCallable ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>Returns a cold synchronous and stateless generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , S > Observable < T > generate ( Callable < S > initialState , BiFunction < S , Emitter < T > , S > generator ) { return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>Returns a cold synchronous and stateless generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybe ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>Returns a cold synchronous and stateless generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing , U extends Collection < ? super T > > Observable < U > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; ObjectHelper . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>Returns a cold synchronous and stateless generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > cacheWithInitialCapacity ( int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return RxJavaPlugins . onAssembly ( new ObservableCache < T > ( this , initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>Flattens an ObservableSource that emits ObservableSources into a single ObservableSource that emits the items emitted by those ObservableSources without any transformation . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . oo . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( ObservableSource ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > generate ( final Consumer < Emitter < T > > generator ) { ObjectHelper . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . < Object > nullSupplier ( ) , ObservableInternalHelper . simpleGenerator ( generator ) , Functions . < Object > emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>Flattens an ObservableSource that emits ObservableSources into a single ObservableSource that emits the items emitted by those ObservableSources without any transformation . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . oo . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( ObservableSource ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static < T > Observable < T > merge ( ObservableSource < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE , bufferSize ( ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>Flattens an ObservableSource that emits ObservableSources into a single ObservableSource that emits the items emitted by those ObservableSources without any transformation . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . oo . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( ObservableSource ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > any ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAnySingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>Flattens an ObservableSource that emits ObservableSources into a single ObservableSource that emits the items emitted by those ObservableSources without any transformation . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . oo . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( ObservableSource ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper ) { return concatMapSingle ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>Flattens an ObservableSource that emits ObservableSources into a single ObservableSource that emits the items emitted by those ObservableSources without any transformation . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . oo . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( ObservableSource ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>Flattens an ObservableSource that emits ObservableSources into a single ObservableSource that emits the items emitted by those ObservableSources without any transformation . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . oo . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( ObservableSource ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count ) { return buffer ( timespan , unit , scheduler , count , ArrayListSupplier . < T > asCallable ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>Flattens an ObservableSource that emits ObservableSources into a single ObservableSource that emits the items emitted by those ObservableSources without any transformation . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . oo . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( ObservableSource ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , S > Observable < T > generate ( Callable < S > initialState , BiFunction < S , Emitter < T > , S > generator ) { return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>Flattens an ObservableSource that emits ObservableSources into a single ObservableSource that emits the items emitted by those ObservableSources without any transformation . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . oo . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( ObservableSource ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybe ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>Flattens an ObservableSource that emits ObservableSources into a single ObservableSource that emits the items emitted by those ObservableSources without any transformation . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . oo . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( ObservableSource ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing , U extends Collection < ? super T > > Observable < U > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; ObjectHelper . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>Flattens an ObservableSource that emits ObservableSources into a single ObservableSource that emits the items emitted by those ObservableSources without any transformation . <p > <img width = 640 height = 370 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / merge . oo . png alt = > <p > You can combine the items emitted by multiple ObservableSources so that they appear as a single ObservableSource by using the { @code merge } method . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code merge } does not operate by default on a particular { @link Scheduler } . < / dd > <dt > <b > Error handling : < / b > < / dt > <dd > If any of the source { @code ObservableSource } s signal a { @code Throwable } via { @code onError } the resulting { @code Observable } terminates with that { @code Throwable } and all other source { @code ObservableSource } s are disposed . If more than one { @code ObservableSource } signals an error the resulting { @code Observable } may terminate with the first one s error or depending on the concurrency of the sources may terminate with a { @code CompositeException } containing two or more of the various error signals . { @code Throwable } s that didn t make into the composite will be sent ( individually ) to the global error handler via { @link RxJavaPlugins#onError ( Throwable ) } method as { @code UndeliverableException } errors . Similarly { @code Throwable } s signaled by source ( s ) after the returned { @code Observable } has been disposed or terminated with a ( composite ) error will be sent to the same global error handler . Use { @link #mergeDelayError ( ObservableSource ) } to merge sources and terminate only when all source { @code ObservableSource } s have completed or failed with an error . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > cacheWithInitialCapacity ( int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return RxJavaPlugins . onAssembly ( new ObservableCache < T > ( this , initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>Returns a Single that emits { @code true } if any item emitted by the source ObservableSource satisfies a specified condition otherwise { @code false } . <em > Note : < / em > this always emits { @code false } if the source ObservableSource is empty . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / any . 2 . png alt = > <p > In Rx . Net this is the { @code any } Observer but we renamed it in RxJava to better match Java naming idioms . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code any } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > generate ( final Consumer < Emitter < T > > generator ) { ObjectHelper . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . < Object > nullSupplier ( ) , ObservableInternalHelper . simpleGenerator ( generator ) , Functions . < Object > emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>Returns a Single that emits { @code true } if any item emitted by the source ObservableSource satisfies a specified condition otherwise { @code false } . <em > Note : < / em > this always emits { @code false } if the source ObservableSource is empty . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / any . 2 . png alt = > <p > In Rx . Net this is the { @code any } Observer but we renamed it in RxJava to better match Java naming idioms . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code any } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static < T > Observable < T > merge ( ObservableSource < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE , bufferSize ( ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>Returns a Single that emits { @code true } if any item emitted by the source ObservableSource satisfies a specified condition otherwise { @code false } . <em > Note : < / em > this always emits { @code false } if the source ObservableSource is empty . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / any . 2 . png alt = > <p > In Rx . Net this is the { @code any } Observer but we renamed it in RxJava to better match Java naming idioms . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code any } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > any ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAnySingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>Returns a Single that emits { @code true } if any item emitted by the source ObservableSource satisfies a specified condition otherwise { @code false } . <em > Note : < / em > this always emits { @code false } if the source ObservableSource is empty . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / any . 2 . png alt = > <p > In Rx . Net this is the { @code any } Observer but we renamed it in RxJava to better match Java naming idioms . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code any } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper ) { return concatMapSingle ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>Returns a Single that emits { @code true } if any item emitted by the source ObservableSource satisfies a specified condition otherwise { @code false } . <em > Note : < / em > this always emits { @code false } if the source ObservableSource is empty . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / any . 2 . png alt = > <p > In Rx . Net this is the { @code any } Observer but we renamed it in RxJava to better match Java naming idioms . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code any } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>Returns a Single that emits { @code true } if any item emitted by the source ObservableSource satisfies a specified condition otherwise { @code false } . <em > Note : < / em > this always emits { @code false } if the source ObservableSource is empty . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / any . 2 . png alt = > <p > In Rx . Net this is the { @code any } Observer but we renamed it in RxJava to better match Java naming idioms . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code any } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count ) { return buffer ( timespan , unit , scheduler , count , ArrayListSupplier . < T > asCallable ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>Returns a Single that emits { @code true } if any item emitted by the source ObservableSource satisfies a specified condition otherwise { @code false } . <em > Note : < / em > this always emits { @code false } if the source ObservableSource is empty . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / any . 2 . png alt = > <p > In Rx . Net this is the { @code any } Observer but we renamed it in RxJava to better match Java naming idioms . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code any } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , S > Observable < T > generate ( Callable < S > initialState , BiFunction < S , Emitter < T > , S > generator ) { return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>Returns a Single that emits { @code true } if any item emitted by the source ObservableSource satisfies a specified condition otherwise { @code false } . <em > Note : < / em > this always emits { @code false } if the source ObservableSource is empty . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / any . 2 . png alt = > <p > In Rx . Net this is the { @code any } Observer but we renamed it in RxJava to better match Java naming idioms . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code any } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybe ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>Returns a Single that emits { @code true } if any item emitted by the source ObservableSource satisfies a specified condition otherwise { @code false } . <em > Note : < / em > this always emits { @code false } if the source ObservableSource is empty . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / any . 2 . png alt = > <p > In Rx . Net this is the { @code any } Observer but we renamed it in RxJava to better match Java naming idioms . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code any } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing , U extends Collection < ? super T > > Observable < U > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; ObjectHelper . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>Returns a Single that emits { @code true } if any item emitted by the source ObservableSource satisfies a specified condition otherwise { @code false } . <em > Note : < / em > this always emits { @code false } if the source ObservableSource is empty . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / any . 2 . png alt = > <p > In Rx . Net this is the { @code any } Observer but we renamed it in RxJava to better match Java naming idioms . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code any } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > cacheWithInitialCapacity ( int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return RxJavaPlugins . onAssembly ( new ObservableCache < T > ( this , initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > generate ( final Consumer < Emitter < T > > generator ) { ObjectHelper . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . < Object > nullSupplier ( ) , ObservableInternalHelper . simpleGenerator ( generator ) , Functions . < Object > emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static < T > Observable < T > merge ( ObservableSource < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE , bufferSize ( ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > any ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAnySingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper ) { return concatMapSingle ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count ) { return buffer ( timespan , unit , scheduler , count , ArrayListSupplier . < T > asCallable ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , S > Observable < T > generate ( Callable < S > initialState , BiFunction < S , Emitter < T > , S > generator ) { return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybe ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing , U extends Collection < ? super T > > Observable < U > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; ObjectHelper . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > cacheWithInitialCapacity ( int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return RxJavaPlugins . onAssembly ( new ObservableCache < T > ( this , initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > generate ( final Consumer < Emitter < T > > generator ) { ObjectHelper . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . < Object > nullSupplier ( ) , ObservableInternalHelper . simpleGenerator ( generator ) , Functions . < Object > emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static < T > Observable < T > merge ( ObservableSource < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE , bufferSize ( ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > any ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAnySingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper ) { return concatMapSingle ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count ) { return buffer ( timespan , unit , scheduler , count , ArrayListSupplier . < T > asCallable ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , S > Observable < T > generate ( Callable < S > initialState , BiFunction < S , Emitter < T > , S > generator ) { return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybe ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing , U extends Collection < ? super T > > Observable < U > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; ObjectHelper . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > cacheWithInitialCapacity ( int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return RxJavaPlugins . onAssembly ( new ObservableCache < T > ( this , initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > generate ( final Consumer < Emitter < T > > generator ) { ObjectHelper . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . < Object > nullSupplier ( ) , ObservableInternalHelper . simpleGenerator ( generator ) , Functions . < Object > emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static < T > Observable < T > merge ( ObservableSource < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE , bufferSize ( ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > any ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAnySingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper ) { return concatMapSingle ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count ) { return buffer ( timespan , unit , scheduler , count , ArrayListSupplier . < T > asCallable ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , S > Observable < T > generate ( Callable < S > initialState , BiFunction < S , Emitter < T > , S > generator ) { return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybe ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing , U extends Collection < ? super T > > Observable < U > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; ObjectHelper . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits connected non - overlapping buffers each of a fixed duration specified by the { @code timespan } argument as measured on the specified { @code scheduler } or a maximum size specified by the { @code count } argument ( whichever is reached first ) . When the source ObservableSource completes the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource . Note that if the source ObservableSource issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 320 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer6 . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > cacheWithInitialCapacity ( int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return RxJavaPlugins . onAssembly ( new ObservableCache < T > ( this , initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>Returns a cold synchronous and stateful generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > generate ( final Consumer < Emitter < T > > generator ) { ObjectHelper . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . < Object > nullSupplier ( ) , ObservableInternalHelper . simpleGenerator ( generator ) , Functions . < Object > emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>Returns a cold synchronous and stateful generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static < T > Observable < T > merge ( ObservableSource < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE , bufferSize ( ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>Returns a cold synchronous and stateful generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > any ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAnySingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>Returns a cold synchronous and stateful generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper ) { return concatMapSingle ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>Returns a cold synchronous and stateful generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>Returns a cold synchronous and stateful generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count ) { return buffer ( timespan , unit , scheduler , count , ArrayListSupplier . < T > asCallable ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>Returns a cold synchronous and stateful generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , S > Observable < T > generate ( Callable < S > initialState , BiFunction < S , Emitter < T > , S > generator ) { return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>Returns a cold synchronous and stateful generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybe ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>Returns a cold synchronous and stateful generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing , U extends Collection < ? super T > > Observable < U > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; ObjectHelper . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>Returns a cold synchronous and stateful generator of values . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / generate . 2 . png alt = > <p > Note that the { @link Emitter#onNext } { @link Emitter#onError } and { @link Emitter#onComplete } methods provided to the function via the { @link Emitter } instance should be called synchronously never concurrently and only while the function body is executing . Calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code generate } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > cacheWithInitialCapacity ( int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return RxJavaPlugins . onAssembly ( new ObservableCache < T > ( this , initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > generate ( final Consumer < Emitter < T > > generator ) { ObjectHelper . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . < Object > nullSupplier ( ) , ObservableInternalHelper . simpleGenerator ( generator ) , Functions . < Object > emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static < T > Observable < T > merge ( ObservableSource < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE , bufferSize ( ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > any ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAnySingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper ) { return concatMapSingle ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count ) { return buffer ( timespan , unit , scheduler , count , ArrayListSupplier . < T > asCallable ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , S > Observable < T > generate ( Callable < S > initialState , BiFunction < S , Emitter < T > , S > generator ) { return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybe ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing , U extends Collection < ? super T > > Observable < U > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; ObjectHelper . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>Maps the upstream items into {<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > cacheWithInitialCapacity ( int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return RxJavaPlugins . onAssembly ( new ObservableCache < T > ( this , initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > generate ( final Consumer < Emitter < T > > generator ) { ObjectHelper . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . < Object > nullSupplier ( ) , ObservableInternalHelper . simpleGenerator ( generator ) , Functions . < Object > emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static < T > Observable < T > merge ( ObservableSource < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE , bufferSize ( ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > any ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAnySingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper ) { return concatMapSingle ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count ) { return buffer ( timespan , unit , scheduler , count , ArrayListSupplier . < T > asCallable ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , S > Observable < T > generate ( Callable < S > initialState , BiFunction < S , Emitter < T > , S > generator ) { return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybe ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing , U extends Collection < ? super T > > Observable < U > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; ObjectHelper . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>Returns an Observable that emits buffers of items it collects from the source ObservableSource . The resulting ObservableSource emits buffers that it creates when the specified { @code openingIndicator } ObservableSource emits an item and closes when the ObservableSource returned from { @code closingIndicator } emits an item . If any of the source ObservableSource { @code openingIndicator } or { @code closingIndicator } issues an onError notification the event is passed on immediately without first emitting the buffer it is in the process of assembling . <p > <img width = 640 height = 470 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / buffer2 . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > This version of { @code buffer } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl ><CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > cacheWithInitialCapacity ( int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return RxJavaPlugins . onAssembly ( new ObservableCache < T > ( this , initialCapacity ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2045-L2052<CODESPLIT>Returns an Observable that subscribes to this ObservableSource lazily caches all of its events and replays them in the same order as received to all the downstream subscribers . <p > <img width = 640 height = 410 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / cacheWithInitialCapacity . o . png alt = > <p > This is useful when you want an ObservableSource to cache responses and you can t control the subscribe / dispose behavior of all the { @link Observer } s . <p > The operator subscribes only when the first downstream subscriber subscribes and maintains a single subscription towards this ObservableSource . In contrast the operator family of { @link #replay () } that return a { @link ConnectableObservable } require an explicit call to { @link ConnectableObservable#connect () } . <p > <em > Note : < / em > You sacrifice the ability to dispose the origin when you use the { @code cache } Observer so be careful not to use this Observer on ObservableSources that emit an infinite or very large number of items that will use up memory . A possible workaround is to apply takeUntil with a predicate or another source before ( and perhaps after ) the application of cache () . <pre > <code > AtomicBoolean shouldStop = new AtomicBoolean () ;<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > generate ( final Consumer < Emitter < T > > generator ) { ObjectHelper . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . < Object > nullSupplier ( ) , ObservableInternalHelper . simpleGenerator ( generator ) , Functions . < Object > emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2975-L2981<CODESPLIT>Returns an Observable that subscribes to this ObservableSource lazily caches all of its events and replays them in the same order as received to all the downstream subscribers . <p > <img width = 640 height = 410 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / cacheWithInitialCapacity . o . png alt = > <p > This is useful when you want an ObservableSource to cache responses and you can t control the subscribe / dispose behavior of all the { @link Observer } s . <p > The operator subscribes only when the first downstream subscriber subscribes and maintains a single subscription towards this ObservableSource . In contrast the operator family of { @link #replay () } that return a { @link ConnectableObservable } require an explicit call to { @link ConnectableObservable#connect () } . <p > <em > Note : < / em > You sacrifice the ability to dispose the origin when you use the { @code cache } Observer so be careful not to use this Observer on ObservableSources that emit an infinite or very large number of items that will use up memory . A possible workaround is to apply takeUntil with a predicate or another source before ( and perhaps after ) the application of cache () . <pre > <code > AtomicBoolean shouldStop = new AtomicBoolean () ;<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static < T > Observable < T > merge ( ObservableSource < ? extends ObservableSource < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE , bufferSize ( ) ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5072-L5077<CODESPLIT>Returns an Observable that subscribes to this ObservableSource lazily caches all of its events and replays them in the same order as received to all the downstream subscribers . <p > <img width = 640 height = 410 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / cacheWithInitialCapacity . o . png alt = > <p > This is useful when you want an ObservableSource to cache responses and you can t control the subscribe / dispose behavior of all the { @link Observer } s . <p > The operator subscribes only when the first downstream subscriber subscribes and maintains a single subscription towards this ObservableSource . In contrast the operator family of { @link #replay () } that return a { @link ConnectableObservable } require an explicit call to { @link ConnectableObservable#connect () } . <p > <em > Note : < / em > You sacrifice the ability to dispose the origin when you use the { @code cache } Observer so be careful not to use this Observer on ObservableSources that emit an infinite or very large number of items that will use up memory . A possible workaround is to apply takeUntil with a predicate or another source before ( and perhaps after ) the application of cache () . <pre > <code > AtomicBoolean shouldStop = new AtomicBoolean () ;<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < Boolean > any ( Predicate < ? super T > predicate ) { ObjectHelper . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAnySingle < T > ( this , predicate ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7031-L7035<CODESPLIT>Returns an Observable that subscribes to this ObservableSource lazily caches all of its events and replays them in the same order as received to all the downstream subscribers . <p > <img width = 640 height = 410 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / cacheWithInitialCapacity . o . png alt = > <p > This is useful when you want an ObservableSource to cache responses and you can t control the subscribe / dispose behavior of all the { @link Observer } s . <p > The operator subscribes only when the first downstream subscriber subscribes and maintains a single subscription towards this ObservableSource . In contrast the operator family of { @link #replay () } that return a { @link ConnectableObservable } require an explicit call to { @link ConnectableObservable#connect () } . <p > <em > Note : < / em > You sacrifice the ability to dispose the origin when you use the { @code cache } Observer so be careful not to use this Observer on ObservableSources that emit an infinite or very large number of items that will use up memory . A possible workaround is to apply takeUntil with a predicate or another source before ( and perhaps after ) the application of cache () . <pre > <code > AtomicBoolean shouldStop = new AtomicBoolean () ;<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper ) { return concatMapSingle ( mapper , 2 ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L7061-L7067<CODESPLIT>Returns an Observable that subscribes to this ObservableSource lazily caches all of its events and replays them in the same order as received to all the downstream subscribers . <p > <img width = 640 height = 410 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / cacheWithInitialCapacity . o . png alt = > <p > This is useful when you want an ObservableSource to cache responses and you can t control the subscribe / dispose behavior of all the { @link Observer } s . <p > The operator subscribes only when the first downstream subscriber subscribes and maintains a single subscription towards this ObservableSource . In contrast the operator family of { @link #replay () } that return a { @link ConnectableObservable } require an explicit call to { @link ConnectableObservable#connect () } . <p > <em > Note : < / em > You sacrifice the ability to dispose the origin when you use the { @code cache } Observer so be careful not to use this Observer on ObservableSources that emit an infinite or very large number of items that will use up memory . A possible workaround is to apply takeUntil with a predicate or another source before ( and perhaps after ) the application of cache () . <pre > <code > AtomicBoolean shouldStop = new AtomicBoolean () ;<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingle ( Function < ? super T , ? extends SingleSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L5868-L5872<CODESPLIT>Returns an Observable that subscribes to this ObservableSource lazily caches all of its events and replays them in the same order as received to all the downstream subscribers . <p > <img width = 640 height = 410 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / cacheWithInitialCapacity . o . png alt = > <p > This is useful when you want an ObservableSource to cache responses and you can t control the subscribe / dispose behavior of all the { @link Observer } s . <p > The operator subscribes only when the first downstream subscriber subscribes and maintains a single subscription towards this ObservableSource . In contrast the operator family of { @link #replay () } that return a { @link ConnectableObservable } require an explicit call to { @link ConnectableObservable#connect () } . <p > <em > Note : < / em > You sacrifice the ability to dispose the origin when you use the { @code cache } Observer so be careful not to use this Observer on ObservableSources that emit an infinite or very large number of items that will use up memory . A possible workaround is to apply takeUntil with a predicate or another source before ( and perhaps after ) the application of cache () . <pre > <code > AtomicBoolean shouldStop = new AtomicBoolean () ;<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final Observable < List < T > > buffer ( long timespan , TimeUnit unit , Scheduler scheduler , int count ) { return buffer ( timespan , unit , scheduler , count , ArrayListSupplier . < T > asCallable ( ) , false ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L2145-L2149<CODESPLIT>Returns an Observable that subscribes to this ObservableSource lazily caches all of its events and replays them in the same order as received to all the downstream subscribers . <p > <img width = 640 height = 410 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / cacheWithInitialCapacity . o . png alt = > <p > This is useful when you want an ObservableSource to cache responses and you can t control the subscribe / dispose behavior of all the { @link Observer } s . <p > The operator subscribes only when the first downstream subscriber subscribes and maintains a single subscription towards this ObservableSource . In contrast the operator family of { @link #replay () } that return a { @link ConnectableObservable } require an explicit call to { @link ConnectableObservable#connect () } . <p > <em > Note : < / em > You sacrifice the ability to dispose the origin when you use the { @code cache } Observer so be careful not to use this Observer on ObservableSources that emit an infinite or very large number of items that will use up memory . A possible workaround is to apply takeUntil with a predicate or another source before ( and perhaps after ) the application of cache () . <pre > <code > AtomicBoolean shouldStop = new AtomicBoolean () ;<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T , S > Observable < T > generate ( Callable < S > initialState , BiFunction < S , Emitter < T > , S > generator ) { return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6908-L6914<CODESPLIT>Returns an Observable that subscribes to this ObservableSource lazily caches all of its events and replays them in the same order as received to all the downstream subscribers . <p > <img width = 640 height = 410 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / cacheWithInitialCapacity . o . png alt = > <p > This is useful when you want an ObservableSource to cache responses and you can t control the subscribe / dispose behavior of all the { @link Observer } s . <p > The operator subscribes only when the first downstream subscriber subscribes and maintains a single subscription towards this ObservableSource . In contrast the operator family of { @link #replay () } that return a { @link ConnectableObservable } require an explicit call to { @link ConnectableObservable#connect () } . <p > <em > Note : < / em > You sacrifice the ability to dispose the origin when you use the { @code cache } Observer so be careful not to use this Observer on ObservableSources that emit an infinite or very large number of items that will use up memory . A possible workaround is to apply takeUntil with a predicate or another source before ( and perhaps after ) the application of cache () . <pre > <code > AtomicBoolean shouldStop = new AtomicBoolean () ;<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapMaybe ( Function < ? super T , ? extends MaybeSource < ? extends R > > mapper , int prefetch ) { ObjectHelper . requireNonNull ( mapper , "mapper is null" ) ; ObjectHelper . verifyPositive ( prefetch , "prefetch" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapMaybe < T , R > ( this , mapper , ErrorMode . IMMEDIATE , prefetch ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6014-L6024<CODESPLIT>Returns an Observable that subscribes to this ObservableSource lazily caches all of its events and replays them in the same order as received to all the downstream subscribers . <p > <img width = 640 height = 410 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / cacheWithInitialCapacity . o . png alt = > <p > This is useful when you want an ObservableSource to cache responses and you can t control the subscribe / dispose behavior of all the { @link Observer } s . <p > The operator subscribes only when the first downstream subscriber subscribes and maintains a single subscription towards this ObservableSource . In contrast the operator family of { @link #replay () } that return a { @link ConnectableObservable } require an explicit call to { @link ConnectableObservable#connect () } . <p > <em > Note : < / em > You sacrifice the ability to dispose the origin when you use the { @code cache } Observer so be careful not to use this Observer on ObservableSources that emit an infinite or very large number of items that will use up memory . A possible workaround is to apply takeUntil with a predicate or another source before ( and perhaps after ) the application of cache () . <pre > <code > AtomicBoolean shouldStop = new AtomicBoolean () ;<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < TOpening , TClosing , U extends Collection < ? super T > > Observable < U > buffer ( ObservableSource < ? extends TOpening > openingIndicator , Function < ? super TOpening , ? extends ObservableSource < ? extends TClosing > > closingIndicator , Callable < U > bufferSupplier ) { ObjectHelper . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; ObjectHelper . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; ObjectHelper . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; }
1<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L6295-L6300<CODESPLIT>Returns an Observable that subscribes to this ObservableSource lazily caches all of its events and replays them in the same order as received to all the downstream subscribers . <p > <img width = 640 height = 410 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / cacheWithInitialCapacity . o . png alt = > <p > This is useful when you want an ObservableSource to cache responses and you can t control the subscribe / dispose behavior of all the { @link Observer } s . <p > The operator subscribes only when the first downstream subscriber subscribes and maintains a single subscription towards this ObservableSource . In contrast the operator family of { @link #replay () } that return a { @link ConnectableObservable } require an explicit call to { @link ConnectableObservable#connect () } . <p > <em > Note : < / em > You sacrifice the ability to dispose the origin when you use the { @code cache } Observer so be careful not to use this Observer on ObservableSources that emit an infinite or very large number of items that will use up memory . A possible workaround is to apply takeUntil with a predicate or another source before ( and perhaps after ) the application of cache () . <pre > <code > AtomicBoolean shouldStop = new AtomicBoolean () ;<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > cacheWithInitialCapacity ( int initialCapacity ) { ObjectHelper . verifyPositive ( initialCapacity , "initialCapacity" ) ; return RxJavaPlugins . onAssembly ( new ObservableCache < T > ( this , initialCapacity ) ) ; }